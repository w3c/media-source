<!DOCTYPE html SYSTEM "about:legacy-compat">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Media Source Extensions</title>
    <script src="respec-w3c-common.js" class="remove"></script>
    <script src="media-source.js" class="remove"></script>
    <script class="remove">
      var respecConfig = {
      // specification status (e.g. WD, LCWD, NOTE, etc.). If in doubt use ED.
      specStatus: "ED",

      // the specification's short name, as in http://www.w3.org/TR/short-name/
      shortName: "media-source",

      // if there a publicly available Editor's Draft, this is the link
      edDraftURI:           "http://dvcs.w3.org/hg/html-media/raw-file/default/media-source/media-source.html",

      // if this is a LCWD, uncomment and set the end of its review period
      // lcEnd: "2009-08-05",

      // editors, add as many as you like
      // only "name" is required
      editors:  [
      { name: "Aaron Colwell",  url: "",
      company: "Google Inc.", companyURL: "http://www.google.com/" },
      { name: "Adrian Bateman", url: "",
      company: "Microsoft Corporation", companyURL: "http://www.microsoft.com/" },
      { name: "Mark Watson", url: "",
      company: "Netflix Inc.", companyURL: "http://www.netflix.com/" },
      ],

      // name of the WG
      wg:           "HTML Working Group",

      // URI of the public WG page
      wgURI:        "http://www.w3.org/html/wg/",

      // name (without the @w3c.org) of the public mailing to which comments are due
      wgPublicList: "public-html-media",

      // URI of the patent status for this WG, for Rec-track documents
      // !!!! IMPORTANT !!!!
      // This is important for Rec-track documents, do not copy a patent URI from a random
      // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
      // Team Contact.
      wgPatentURI: "http://www.w3.org/2004/01/pp-impl/40318/status",

      noIDLIn: true,

      postProcess: [ mediaSourcePostProcessor ]
      };
    </script>

    <style type="text/css">
      .nonnormative { color: green; margin: 2em 0 2em 0em; padding: 0.5em 1em; border: none; background: #DDFFDD; }
      .nonnormative h3 { color: inherit; background: inherit; }
      .nonnormative:before { display: table; margin: -1em -0.5em -0.5em auto; width: auto; content: 'This section is non-normative.'; color: black; font-style: italic; border: solid 2px; background: white; padding: 0 0.25em; }

      .iso-box { font-weight: bold; }
      .iso-var { font-style: italic; }

      table.old-table { border-collapse: collapse; border-style: hidden hidden none hidden; }
      table.old-table thead, table tbody { border-bottom: solid; }
      table.old-table tbody th:first-child { border-left: solid; }
      table.old-table tbody th { text-align: left; }
      table.old-table td, table th { border-left: solid; border-right: solid; border-bottom: solid thin; vertical-align: top; padding: 0.2em; }

      dl.switch { padding-left: 2em; }
      dl.switch > dt { text-indent: -1.5em; }
      dl.switch > dt:before { content: '\21AA'; padding: 0 0.5em 0 0; display: inline-block; width: 1em; text-align: right; line-height: 0.5em; }

      p + * > li, dd li { margin: 1em 0; }

      @media screen { code :link, code :visited { color: inherit; } }
    </style>
  </head>
  <body>
    
    <section id="sotd">
        <p>The working groups maintains <a href="http://w3.org/brief/Mjcw">a list of all bug reports that the editors have not yet tried to address</a>. This draft highlights some of the pending issues that are still to be discussed in the working group. No decision has been taken on the outcome of these issues including whether they are valid.</p>
        <p>Implementors should be aware that this specification is not stable. <strong>Implementors who are not taking part in the discussions are likely to find the specification changing out from under them in incompatible ways.</strong> Vendors interested in implementing this specification before it eventually reaches the Candidate Recommendation stage should join the mailing list mentioned below and take part in the discussions.</p>
    </section>

    <section id="abstract">
      This specification extends HTMLMediaElement to allow 
      JavaScript to generate media streams for playback. 
      Allowing JavaScript to generate streams facilitates a variety of use 
      cases like adaptive streaming and time shifting live streams.
    </section>


    <section id="introduction">
      <h2>Introduction</h2>
      <p>This specification allows JavaScript to dynamically construct media streams for &lt;audio&gt; and &lt;video&gt;. 
        It defines objects that allow JavaScript to pass media segments to an <a def-id="videoref" name="htmlmediaelement">HTMLMediaElement</a>.
        A buffering model is also included to describe how the user agent should act when different media segments are 
        appended at different times. Byte stream specifications for WebM, ISO Base Media File Format, and MPEG-2 Transport Streams are given to specify the
        expected format of byte streams used with these extensions.</p>
      <img src="pipeline_model.png" alt="Media Source Pipeline Model Diagram">

      <section id="goals">
        <h3>Goals</h3>
        <p>This specification was designed with the following goals in mind:</p>
        <ul>
          <li>Allow JavaScript to construct media streams independent of how the media is fetched.</li>
          <li>Define a splicing and buffering model that facilitates use cases like adaptive streaming, ad-insertion, time-shifting, and video editing.</li>
          <li>Minimize the need for media parsing in JavaScript.</li>
          <li>Leverage the browser cache as much as possible.</li>
          <li>Provide byte stream definitions for WebM, the ISO Base Media File Format, and MPEG-2 Transport Streams.</li>
          <li>Not require support for any particular media format or codec.</li>
        </ul>
      </section>

      <section id="definitions">
        <h3>Definitions</h3>

        <dl>
          <dt id="init-segment">Initialization Segment</dt>
          <dd>
	    <p>A sequence of bytes that contain all of the initialization information required to decode a sequence of <a def-id="media-segments"></a>. This includes codec initialization data, <a def-id="track-id"></a> mappings for multiplexed segments, and timestamp offsets (e.g. edit lists).</p>
            <p class="note">The <a def-id="byte-stream-format-specs"></a> contain format specific examples.</p>

          <dt id="media-segment">Media Segment</dt>
          <dd>
	    <p>A sequence of bytes that contain packetized &amp; timestamped media data for a portion of the presentation timeline. Media segments are always associated with the most recently appended <a def-id="init-segment"></a>.</p>
            <p class="note">The <a def-id="byte-stream-format-specs"></a> contain format specific examples.</p>
          </dd>

          <dt id="decoder-buffer">Decoder Buffer</dt>
          <dd><p>A buffer that holds initialization data and <a def-id="coded-frames"></a> that will be decoded and rendered. This buffer may not exist in actual implementations, but it is intended to represent media data that will be decoded no matter what <a def-id="media-segments"></a> are appended to update the <a>SourceBuffer</a>. This distinction is important when considering appends that happen close to the current playback position. See <a href="#track-buffer-to-decoder-buffer">Track Buffer to Decoder Buffer transfer</a> for details.</p></dd>

          <dt id="random-access-point">Random Access Point</dt>
          <dd><p>A position in a <a def-id="media-segment"></a> where decoding and continuous playback can begin without relying on any previous data in the segment. For video this tends to be the location of I-frames. In the case of audio, most audio frames can be treated as a random access point. Since video tracks tend to have a more sparse distribution of random access points, the location of these points are usually considered the random access points for multiplexed streams.</p></dd>

          <dt id="presentation-start-time">Presentation Start Time</dt>
          <dd><p>The presentation start time is the earliest time point in the presentation and specifies the <a def-id="videoref" name="initial-playback-position">initial playback position</a> and <a def-id="videoref" name="earliest-possible-position">earliest possible position</a>. All presentations created using this specification have a presentation start time of 0.</dd>

          <dt id="mediasource-object-url">MediaSource object URL</dt>
          <dd>
            <p>A MediaSource object URL is a unique <a def-id="blob-uri"></a> created by <a def-id="createObjectURL"></a>. It is used to attach a <a>MediaSource</a> object to an HTMLMediaElement.</p>
            <p>These URLs are the same as what the <a def-id="FileAPI"></a> specification calls a <a def-id="blob-uri"></a>, except that anything in the definition of that feature that refers to <a def-id="File"></a> and <a def-id="Blob"></a> objects is hereby extended to also apply to <a>MediaSource</a> objects.</p>
          </dd>

          <dt id="track-id">Track ID</dt>
          <dd><p>A Track ID is a byte stream format specific identifier that marks sections of the byte stream as being part of a specific track. The Track ID in a <a def-id="track-description"></a> identifies which sections of a <a def-id="media-segment"></a> belong to that track.</p></dd>

          <dt id="track-description">Track Description</dt>
          <dd><p>A byte stream format specific structure that provides the <a def-id="track-id"></a>, codec configuration, and other metadata for a single track. Each track description inside a single <a def-id="init-segment"></a> must have a unique <a def-id="track-id"></a>.</p></dd>

          <dt id="coded-frame">Coded Frame</dt>
          <dd><p>A unit of compressed media data that has a presentation timestamp and  decode timestamp. The presentation timestamp indicates when the frame should be rendered. The decode timestamp indicates when the frame needs to be decoded. If frames can be decoded out of order, then the decode timestamp must be present in the bytestream. If frames cannot be decoded out of order and a decode timestamp is not present in the bytestream, then the decode timestamp is equal to the presentation timestamp.</p></dd>

          <dt id="parent-media-source">Parent Media Source</dt>
          <dd>The parent media source of a <a>SourceBuffer</a> object is the <a>MediaSource</a> object that created it.</dd>

          <dt id="append-sequence">Append Sequence</dt>
          <dd>A series of <a def-id="appendArrayBuffer"></a> or <a def-id="appendStream"></a> calls on a <a>SourceBuffer</a> without any intervening <a def-id="abort"></a> calls. The
          <a def-id="media-segments"></a> in an append sequence must be adjacent and monotonically increasing in time without any gaps. An
          <a def-id="abort"></a> call starts a new append sequence which allows <a def-id="media-segments"></a> to be appended in non-monotonically
          increasing order.</dd>
        </dl>
      </section>
    </section>


    <section id="source-buffer-model">
      <h2>Source Buffer Model</h2>
      <div class="nonnormative">
        <p>The subsections below outline the buffering model for this specification. It describes the various rules and behaviors associated with appending
 data to an individual <a>SourceBuffer</a>. At the highest level, the web application creates <a>SourceBuffer</a> objects and appends sequences of 
<a def-id="init-segments"></a> and <a def-id="media-segments"></a> to update their state. The media element pulls media data out of the 
<a>MediaSource</a> object, plays it, and fires events just like it would if a normal URL was passed to the <a def-id="media-src"></a> attribute.
 The web application is expected to monitor media element events to determine when it needs to append more <a def-id="media-segments"></a>.</p>
      </div>

      <section id="source-buffer-overlapping-segments">
        <h3>Appending a Media Segment over a buffered region</h3>
        <p>There are several ways that <a def-id="media-segments"></a> can overlap segments in the <a>SourceBuffer</a>. Behavior for the different overlap situations are described below. If more than one overlap applies, then the <a href="#source-buffer-overlap-start">start overlap</a> must be resolved first, followed by any <a href="#source-buffer-overlap-complete">complete overlaps</a>, and finally the <a href="#source-buffer-overlap-end">end overlap</a>. If a segment contains multiple tracks then the overlap is resolved independently for each track.</p>

        <p class="issue"><a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=19673">Bug 19673</a> - Seamless audio signal transitions at splice points</p>
        <p class="issue"><a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=19784">Bug 19784</a> - timestampOffset with multiplexed Media Segments</p>

        <section id="source-buffer-overlap-complete">
          <h4>Complete Overlap</h4>
          <img src="complete_overlap.png" alt="Complete overlap diagram">
          <p>The figure above shows how the <a>SourceBuffer</a> is updated when a new <a def-id="media-segment"></a> completely overlaps a segment in the buffer. In this case, the new segment completely replaces the old segment.</p>
        </section>

        <section id="source-buffer-overlap-start">
          <h4>Start Overlap</h4>
          <img src="start_overlap.png" alt="Start overlap diagram">
          <p>The figure above shows how the <a>SourceBuffer</a> is updated when the beginning of a new <a def-id="media-segment"></a> overlaps a segment in the buffer. In this case, the new segment replaces all the old media data in the overlapping region. Since <a def-id="media-segments"></a> are constrained to starting with <a def-id="random-access-points"></a>, this provides a seamless transition between segments.</p>
          <p>When an audio frame in the <a>SourceBuffer</a> overlaps with the start of the new <a def-id="media-segment"></a> special behavior is required. At a minimum implementations must support dropping the old audio frame that overlaps the start of the new segment and insert silence for the small gap that is created. Higher quality implementations may support crossfading or crosslapping between the overlapping audio frames. No matter which strategy is implemented, no gaps are created in the ranges reported by <a def-id="buffered"></a> and playback must never stall at the overlap.</p>
        </section>

        <section id="source-buffer-overlap-end">
          <h4>End Overlap</h4>
          <img src="end_overlap.png" alt="End overlap diagram">
          <p>The figure above shows how the <a>SourceBuffer</a> is updated when the end of a new <a def-id="media-segment"></a> overlaps the beginning of a segment in the buffer. In this case, the <a>SourceBuffer</a> tries to keep as much of the old segment as possible. The amount saved depends on where the closest <a def-id="random-access-point"></a>, in the old segment, is to the end of the new segment. In the case of audio, if the gap is smaller than the size of an audio frame, then the <a>SourceBuffer</a> may render silence for this gap. This gap must not be reflect in <a def-id="buffered"></a>. The entire new segment must be added to the <a>SourceBuffer</a>, but it is up to the implementation to determine how much of the old segment data is retained.</p>


          <p class="note">An implementation may keep old segment data before the end of the new segment to avoid creating a gap if it wishes. Doing this though can significantly increase implementation complexity and could cause delays at the splice point.</p>

          <p class="note"> The web application can use <a def-id="buffered"></a> to determine how much of the old segment was preserved.</p>
        </section>

        <section id="source-buffer-overlap-middle">
          <h4>Middle Overlap</h4>
          <img src="middle_overlap.png" alt="Middle overlap diagram">
          <p>The figure above shows how the <a>SourceBuffer</a> is updated when the new <a def-id="media-segment"></a> is in the middle of the old segment. This condition is handled by first resolving the <a href="#source-buffer-overlap-start">start overlap</a> and then resolving the <a href="#source-buffer-overlap-end">end overlap</a>.</p>
        </section>
      </section>

      <section id="track-buffer-to-decoder-buffer">
        <h3>Track Buffer to Decoder Buffer transfer</h3>
        <div class="nonnormative">
        <p>The <a def-id="track-buffer"></a> represents the media that the web application would like the media element to play. The <a def-id="decoder-buffer"></a> contains the data that will actually get decoded and rendered. In most cases the <a def-id="decoder-buffer"></a> will simply contain a subset of the <a def-id="track-buffer"></a> near the current playback position. These two buffers start to diverge when <a def-id="media-segments"></a> that overlap or are very close to the current playback position are appended. Depending on the contents of the new <a def-id="media-segment"></a> it may not be possible to switch to the new data immediately because there isn't a <a def-id="random-access-point"></a> close enough to the current playback position. The quality of the implementation determines how much data is considered &quot;in the <a def-id="decoder-buffer"></a>.&quot; It should transfer data to the <a def-id="decoder-buffer"></a> as late as possible whilst maintaining seamless playback. Some implementations may be able to instantiate multiple decoders or decode the new data significantly faster than real-time to achieve a seamless splice immediately. Other implementations may delay until the next <a def-id="random-access-point"></a> before switching to the newly appended data. Notice that this difference in behavior is only observable when appending close to the current playback position. The <a def-id="decoder-buffer"></a> represents a media subsegment, like a group of pictures or something with similar decode dependencies, that the media element commits to playing. This commitment may be influenced by a variety of things like limited decoding resources, hardware decode buffers, a jitter buffer, or the desire to limit implementation complexity.</p>

        <p>Here is an example to help clarify the role of the <a def-id="decoder-buffer"></a>. Say the current playback position has a timestamp of 8 and the media element pulled frames with timestamp 9 &amp; 10 into the decoder buffer. The web application then appends a higher quality <a def-id="media-segment"></a> that starts with a <a def-id="random-access-point"></a> at timestamp 9. The <a def-id="track-buffer"></a> will get updated with the higher quality data, but the media element won't be able to switch to this higher quality data until the next <a def-id="random-access-point"></a> at timestamp 20. This is because a frame for timestamp 9 is already in the decoder buffer. The decoder buffer represents the "point of no return." for decoding. If a seek occurs the media element may choose to use the higher quality data since a seek might imply flushing the <a def-id="decoder-buffer"></a> and the user expects a break in playback.</p>
        </div>
      </section>
    </section>

    <section id="mediasource">
      <h2>MediaSource Object</h2>
      <p>The MediaSource object represents a source of media data for an HTMLMediaElement. It keeps track of the <a def-id="readyState"></a> for this source as well as a list of <a>SourceBuffer</a> objects that can be used to add media data to the presentation. MediaSource objects are created by the web application and then attached to an HTMLMediaElement. The application uses the <a>SourceBuffer</a> objects in <a def-id="sourceBuffers"></a> to add media data to this source. The HTMLMediaElement fetches this media data from the <a>MediaSource</a> object when it is needed during playback.</p>

      <dl title="enum ReadyState" class="idl">
        <dt>closed</dt>
        <dd>
          Indicates the source is not currently attached to a media element.
        </dd>
        <dt>open</dt>
        <dd>
          The source has been opened by a media element and is ready for data to be appended to the <a>SourceBuffer</a> objects in <a def-id="sourceBuffers"></a>.
        </dd>
        <dt>ended</dt>
        <dd>
          The source is still attached to a media element, but <a def-id="endOfStream"></a> has been called.
        </dd>
      </dl>

      <dl title="enum EndOfStreamError" class="idl">
        <dt>network</dt>
        <dd>
          <p>Terminates playback and signals that a network error has occured.</p>
          <p class="note">If the JavaScript fetching media data encounters a network error it should use this status code to terminate playback.</p>
        </dd>
        <dt>decode</dt>
        <dd>
          <p>Terminates playback and signals that a decoding error has occured.</p>
          <p class="note">If the JavaScript code fetching media data has problems parsing the data it should use this status code to terminate playback.</p>
        </dd>
      </dl>

      <dl title="[Constructor] interface MediaSource : EventTarget" class='idl'>
        <dt>readonly attribute SourceBufferList sourceBuffers</dt>
        <dd>
          Contains the list of <a>SourceBuffer</a> objects associated with this <a>MediaSource</a>. When <a def-id="readyState"></a> equals <a def-id="closed"></a> this list will be empty. Once <a def-id="readyState"></a> transitions to <a def-id="open"></a> SourceBuffer objects can be added to this list by using <a def-id="addSourceBuffer"></a>.
        </dd>

        <dt>readonly attribute SourceBufferList activeSourceBuffers</dt>
        <dd>
          <p>Contains the subset of <a def-id="sourceBuffers"></a> that are providing the 
            <a def-id="videoref" name="dom-videotrack-selected">selected video track</a>,  the 
            <a def-id="videoref" name="dom-audiotrack-enabled">enabled audio tracks</a>, and the 
            <a def-id="videoref" name="dom-texttrack-showing">"showing"</a> or <a def-id="videoref" name="dom-texttrack-hidden">"hidden"</a> text tracks.
          </p>
          <p class="note">The <a href="#active-source-buffer-changes">Changes to selected/enabled track state</a> section describes how this attribute gets
            updated.</p>
        </dd>

        <dt>readonly attribute ReadyState readyState</dt>
        <dd>
          <p>Indicates the current state of the <a>MediaSource</a> object. When the <a>MediaSource</a> is created <a def-id="readyState"></a> must be set to <a def-id="closed"></a>.
        </dd>

        <dt>attribute unrestricted double duration</dt>
        <dd>
          <p>Allows the web application to set the presentation duration. The duration is initially set to NaN when the <a>MediaSource</a> object is created.</p>
          <p>On getting, run the following steps:</p>
          <ol>
            <li>If the <a def-id="readyState"></a> attribute is <a def-id="closed"></a> then return NaN and abort these steps.</li>
            <li>Return the current value of the attribute.</li>
          </ol>
          <p>On setting, run the following steps:</p>
          <ol>
            <li>If the value being set is negative or NaN then throw an <a def-id="invalid-access-err"></a> exception and abort these steps.</li>
            <li>If the <a def-id="readyState"></a> attribute is not <a def-id="open"></a> then throw an <a def-id="invalid-state-err"></a> exception and abort these steps.</li>
            <li>If the <a def-id="updating"></a> attribute equals true on any <a>SourceBuffer</a> in <a def-id="sourceBuffers"></a>, then throw an <a def-id="invalid-state-err"></a> exception and abort these steps.</li>
            <li>Run the <a def-id="duration-change-algorithm"></a> with <var>new duration</var> set to the value being assigned to this attribute.
	      <p class="note"><a def-id="appendArrayBuffer"></a>, <a def-id="appendStream"></a> and <a def-id="endOfStream"></a> can update the duration under certain circumstances.</p>
            </li>
          </ol>
        </dd>

        <dt>SourceBuffer addSourceBuffer(DOMString type)</dt>
        <dd>
          <p>Adds a new <a>SourceBuffer</a> to <a def-id="sourceBuffers"></a>.</p>

          <ol class="method-algorithm">
            <li>If <var>type</var> is null or an empty string then throw an <a def-id="invalid-access-err"></a> exception and abort these steps.</li>
            <li>If <var>type</var> contains a MIME type that is not supported or contains a MIME type that is not supported with the types specified for the other <a>SourceBuffer</a> objects in <a def-id="sourceBuffers"></a>, then throw a <a def-id="not-supported-err"></a> exception and abort these steps.</li>
            <li>If the user agent can't handle any more SourceBuffer objects then throw a <a def-id="quota-exceeded-err"></a> exception and abort these steps.</li>
            <li>If the <a def-id="readyState"></a> attribute is not in the <a def-id="open"></a> state then throw an <a def-id="invalid-state-err"></a> exception and abort these steps.</li>
            <li>Create a new <a>SourceBuffer</a> object and associated resources.</li>
            <li>Add the new object to <a def-id="sourceBuffers"></a> and <a def-id="queue-a-task-to-fire-an-event-named"></a> <a def-id="addsourcebuffer"></a> at <a def-id="sourceBuffers"></a>.</li>
            <li>Return the new object.</li>
          </ol>
        </dd>

        <dt>void removeSourceBuffer(SourceBuffer sourceBuffer)</dt>
        <dd>
          <p>Removes a <a>SourceBuffer</a> from <a def-id="sourceBuffers"></a>.</p>

          <ol class="method-algorithm">
            <li>If <var>sourceBuffer</var> is null then throw an <a def-id="invalid-access-err"></a> exception and abort these steps.</li>
            <li>If <var>sourceBuffer</var> specifies an object that is not in <a def-id="sourceBuffers"></a> then throw a <a def-id="not-found-err"></a> exception and abort these steps.</li>
            <li>If the <var>sourceBuffer</var>.<a def-id="updating"></a> attribute equals true, then run the following steps:
              <ol>
                <li>Abort the <a def-id="stream-append-loop"></a> algorithm if it is running.</li>
                <li>Set the <var>sourceBuffer</var>.<a def-id="updating"></a> attribute to false.</li>
                <li><a def-id="Queue-a-task-to-fire-an-event-named"></a> <a def-id="updateabort"></a> at <var>sourceBuffer</var>.</li>
                <li><a def-id="Queue-a-task-to-fire-an-event-named"></a> <a def-id="updateend"></a> at <var>sourceBuffer</var>.</li>
              </ol>
            </li>
            <li>Set the the sourceBuffer attribute in all tracks in <var>sourceBuffer</var>.<a def-id="sourcebuffer-audioTracks"></a>, <var>sourceBuffer</var>.<a def-id="sourcebuffer-videoTracks"></a>, and <var>sourceBuffer</var>.<a def-id="sourcebuffer-textTracks"></a> to null.</li>
            <li>Remove all the tracks in <var>sourceBuffer</var>.<a def-id="sourcebuffer-audioTracks"></a>, <var>sourceBuffer</var>.<a def-id="sourcebuffer-videoTracks"></a>, and <var>sourceBuffer</var>.<a def-id="sourcebuffer-textTracks"></a> from the respective <a def-id="audiotracks"></a>, <a def-id="videotracks"></a>, and <a def-id="texttracks"></a> attributes on the HTMLMediaElement.</li>
            <li>Remove all the tracks in <var>sourceBuffer</var>.<a def-id="sourcebuffer-audioTracks"></a>, <var>sourceBuffer</var>.<a def-id="sourcebuffer-videoTracks"></a>, and <var>sourceBuffer</var>.<a def-id="sourcebuffer-textTracks"></a> and <a def-id="queue-a-task-to-fire-an-event-named"></a> <a def-id="tracklist-change"></a> at the modified lists.</li>
            <li><a def-id="Queue-a-task-to-fire-an-event-named"></a> <a def-id="tracklist-change"></a> at the HTMLMediaElement track lists that were modified.</li>
            <li>If <var>sourceBuffer</var> is in <a def-id="activeSourceBuffers"></a>, then remove it from <a def-id="activeSourceBuffers"></a> and <a def-id="queue-a-task-to-fire-an-event-named"></a> <a def-id="removesourcebuffer"></a> at <a def-id="activeSourceBuffers"></a>.</li>
            <li>Remove <var>sourceBuffer</var> from <a def-id="sourceBuffers"></a> and <a def-id="queue-a-task-to-fire-an-event-named"></a> <a def-id="removesourcebuffer"></a> at <a def-id="sourceBuffers"></a>.</li>
            <li>Destroy all resources for <var>sourceBuffer</var>.</li>
          </ol>
        </dd>

        <dt>void endOfStream(optional EndOfStreamError error)</dt>
        <dd>
          <p>Signals the end of the stream.</p>

          <ol class="method-algorithm">
            <li>If the <a def-id="readyState"></a> attribute is not in the <a def-id="open"></a> state then throw an <a def-id="invalid-state-err"></a> exception and abort these steps.</li>
            <li>If the <a def-id="updating"></a> attribute equals true on any <a>SourceBuffer</a> in <a def-id="sourceBuffers"></a>, then throw an <a def-id="invalid-state-err"></a> exception and abort these steps.</li>
            <li>Change the <a def-id="readyState"></a> attribute value to <a def-id="ended"></a>.</li>
            <li>
              <a def-id="Queue-a-task-to-fire-an-event-named"></a> <a def-id="sourceended"></a> at the <a>MediaSource</a>.</li>
            <li><dl class="switch">
                <dt>If <var>error</var> is not set, null, or an empty string</dt>
                <dd>
	          <ol>
	            <li>Run the <a def-id="duration-change-algorithm"></a> with <var>new duration</var> set to the highest end timestamp across all <a>SourceBuffer</a> objects in <a def-id="sourceBuffers"></a>.<br>
		      <p class="note">This allows the duration to properly reflect the end of the appended media segments. For example, if the duration was explicitly set to 10 seconds and only media segments for 0 to 5 seconds were appended before endOfStream() was called, then the duration will get updated to 5 seconds.</p>
	            </li>
	            <li>Notify the media element that it now has all of the media data. Playback should continue until all the media passed in via <a def-id="appendArrayBuffer"></a> and <a def-id="appendStream"></a> has been played.</li>
	          </ol>
	        </dd>
                <dt>If <var>error</var> is set to <a def-id="network"></a>
                </dt>
                <dd>
	          <dl class="switch">
	            <dt>If the <a def-id="ready-state"></a> attribute equals <a def-id="have-nothing"></a>
                    </dt>
	            <dd>Run the <a def-id="media-data-cannot-be-fetched"></a> steps of the <a def-id="resource-fetch-algorithm"></a>.</dd>
	            <dt>If the <a def-id="ready-state"></a> attribute is greater than <a def-id="have-nothing"></a>
                    </dt>
	            <dd>Run the "<i>If the connection is interrupted after some media data has been received, causing the user agent to give up trying to fetch the resource</i>" steps of the <a def-id="resource-fetch-algorithm"></a>.</dd>
	          </dl>
	        </dd>
                <dt>If <var>error</var> is set to <a def-id="decode"></a>
                </dt>
                <dd>
	          <dl class="switch">
	            <dt>If the <a def-id="ready-state"></a> attribute equals <a def-id="have-nothing"></a>
                    </dt>
	            <dd>Run the "<i>If the media data can be fetched but is found by inspection to be in an unsupported format, or can otherwise not be rendered at all</i>" steps of the <a def-id="resource-fetch-algorithm"></a>.</dd>
	            <dt>If the <a def-id="ready-state"></a> attribute is greater than <a def-id="have-nothing"></a>
                    </dt>
	            <dd>Run the <a def-id="media-data-is-corrupted"></a> steps of the <a def-id="resource-fetch-algorithm"></a>.</dd>
	          </dl>
	        </dd>
                <dt>Otherwise</dt>
                <dd>Throw an <a def-id="invalid-access-err"></a> exception.</dd>
              </dl>
            </li>
          </ol>
        </dd>

        <dt>static boolean isTypeSupported(DOMString type)</dt>
        <dd>
          <p>Check to see whether the <a>MediaSource</a> is capable of creating <a>SourceBuffer</a> objects for the the specified MIME type.</p>

          <ol class="method-algorithm">
            <li>If <var>type</var> is an empty string, then return false.</li>
            <li>If <var>type</var> does not contain a valid MIME type string, then return false.</li>
            <li>If <var>type</var> contains a media type or media subtype that the MediaSource does not support, then return false.</li>
            <li>If <var>type</var> contains at a codec that the MediaSource does not support, then return false.</li>
            <li>If the MediaSource does not support the specified combination of media type, media subtype, and codecs then return false.</li>
            <li>Return true.</li>
          </ol>
          <p class="note">
            If true is returned from this method, it only indicates that the <a>MediaSource</a> implementation is capable of creating <a>SourceBuffer</a> objects for the specified MIME type. An <a def-id="addSourceBuffer"></a> call may still fail if sufficient resources are not available to support the addition of a new <a>SourceBuffer</a>.
          </p>
          <p class="note">
            This method returning true implies that HTMLMediaElement.canPlayType() will return "maybe" or "probably" since it does not make sense for a <a>MediaSource</a> to support a type the HTMLMediaElement knows it cannot play.
          </p>
        </dd>
      </dl>

      <section id="mediasource-events">
        <h3>Event Summary</h3>
        <table class="old-table">
          <thead>
            <tr>
              <th>Event name</th>
              <th>Interface</th>
              <th>Dispatched when...</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><a def-id="eventdfn">sourceopen</a></td>
              <td><code>Event</code></td>
              <td><a def-id="readyState"></a> transitions from <a def-id="closed"></a> to <a def-id="open"></a> or from <a def-id="ended"></a> to <a def-id="open"></a>.</td>
            </tr>
            <tr>
              <td><a def-id="eventdfn">sourceended</a></td>
              <td><code>Event</code></td>
              <td><a def-id="readyState"></a> transitions from <a def-id="open"></a> to <a def-id="ended"></a>.</td>
            </tr>
            <tr>
              <td><a def-id="eventdfn">sourceclose</a></td>
              <td><code>Event</code></td>
	      <td><a def-id="readyState"></a> transitions from <a def-id="open"></a> to <a def-id="closed"></a> or <a def-id="ended"></a> to <a def-id="closed"></a>.</td>
            </tr>
          </tbody>
        </table>
      </section>

      <section id="mediasource-algorithms">
        <h3>Algorithms</h3>

        <section id="mediasource-attach">
          <h4>Attaching to a media element</h4>
          <p> A <a>MediaSource</a> object can be attached to a media element by assigning a <a def-id="MediaSource-object-URL"></a> to the media element <a def-id="media-src"></a> attribute or the src attribute of a &lt;source&gt; inside a media element. A <a def-id="MediaSource-object-URL"></a> is created by passing a MediaSource object to <a def-id="createObjectURL"></a>.</p>
          <p>If the <a def-id="resource-fetch-algorithm"></a> absolute URL matches the MediaSource object URL, run the following steps right before the "Perform a potentially
            CORS-enabled fetch" step in the <a def-id="resource-fetch-algorithm"></a>.</p>

          <dl class="switch">
            <dt>If <a def-id="readyState"></a> is NOT set to <a def-id="closed"></a></dt>
            <dd>Run the <a def-id="media-data-cannot-be-fetched"></a> steps of the <a def-id="resource-fetch-algorithm"></a>.</dd>
            <dt>Otherwise</dt>
            <dd>
              <ol>
                <li>Set the <a def-id="readyState"></a> attribute to <a def-id="open"></a>.</li>
                <li>
                  <a def-id="Queue-a-task-to-fire-an-event-named"></a> <a def-id="sourceopen"></a> at the <a>MediaSource</a>.</li>
                <li>Allow the <a def-id="resource-fetch-algorithm"></a> to progress based on data passed in via <a def-id="appendArrayBuffer"></a> and <a def-id="appendStream"></a>.</li>
              </ol>
            </dd>
          </dl>
        </section>

        <section id="mediasource-detach">
          <h4>Detaching from a media element</h4>
          <p>The following steps are run in any case where the media element is going to transition to <a def-id="videoref" name="dom-media-network_empty">NETWORK_EMPTY</a> and <a def-id="queue-a-task-to-fire-an-event-named"></a> <a def-id="videoref" name="event-mediacontroller-emptied">emptied</a> at the media element. These steps should be run right before the transition.</p>
          <ol>
            <li>Set the <a def-id="readyState"></a> attribute to <a def-id="closed"></a>.</li>
            <li>Set the <a def-id="duration"></a> attribute to NaN.</li>
            <li>Remove all the <a>SourceBuffer</a> objects from <a def-id="activeSourceBuffers"></a>.</li>
            <li>
              <a def-id="Queue-a-task-to-fire-an-event-named"></a> <a def-id="removesourcebuffer"></a> at <a def-id="activeSourceBuffers"></a>.</li>
            <li>Remove all the <a>SourceBuffer</a> objects from <a def-id="sourceBuffers"></a>.</li>
            <li>
              <a def-id="Queue-a-task-to-fire-an-event-named"></a> <a def-id="removesourcebuffer"></a> at <a def-id="sourceBuffers"></a>.</li>
            <li>
              <a def-id="Queue-a-task-to-fire-an-event-named"></a> <a def-id="sourceclose"></a> at the <a>MediaSource</a>.</li>
          </ol>
        </section>

        <section id="mediasource-seeking">
          <h4>Seeking</h4>
          <p>Run the following steps as part of the "<i>Wait until the user agent has established whether or not the media data for the new playback position is available, and, if it is, until it has decoded enough data to play back that position"</i> step of the <a def-id="hme-seek-algorithm"></a>:</p>
          <ol>
            <li>The media element looks for <a def-id="media-segments"></a> containing the <var>new playback position</var> in each <a>SourceBuffer</a> object in <a def-id="activeSourceBuffers"></a>.
              <dl class="switch">
	        <dt>If one or more of the objects in <a def-id="activeSourceBuffers"></a> is missing <a def-id="media-segments"></a> for the <var>new playback position</var>
                </dt>
	        <dd>
	          <ol>
	            <li>Set the <a def-id="ready-state"></a> attribute to <a def-id="have-metadata"></a>.</li>
	            <li>The media element waits for the necessary <a def-id="media-segments"></a> to be passed to <a def-id="appendArrayBuffer"></a> or <a def-id="appendStream"></a>.
                      <p class="note">The web application can use <a def-id="buffered"></a> to determine what the media element needs to resume playback.</p>
                    </li>
	          </ol>
	        </dd>
	        <dt>Otherwise</dt>
	        <dd>Continue</dd>
              </dl>
            </li>
            <li>The media element resets all decoders and initializes each one with data from the appropriate <a def-id="init-segment"></a>.</li>
            <li>The media element feeds data from the <a def-id="media-segments"></a> into the decoders until the <var>new playback position</var> is reached.</li>
            <li>Resume the <a def-id="hme-seek-algorithm"></a> at the "<i>Await a stable state</i>" step.</li>
          </ol>
        </section>


        <section id="buffer-monitoring">
          <h4>SourceBuffer Monitoring</h4>
          <p>The following steps are periodically run during playback to make sure that all of the <a>SourceBuffer</a> objects in <a def-id="activeSourceBuffers"></a> have <a def-id="enough-data"></a>. Appending new segments and changes to <a def-id="activeSourceBuffers"></a> also cause these steps to run because they affect the conditions that trigger state transitions.</p>

          <p>Having <dfn id="enough-data">enough data to ensure uninterrupted playback</dfn> is an implementation specific condition where the user agent
          determines that it currently has enough data to play the presentation without stalling for a meaningful period of time. This condition is
          constantly evaluated to determine when to transition the media element into and out of the <a def-id="have-enough-data"></a> ready state.
          These transitions indicate when the user agent believes it has enough data buffered or it needs more data respectively.</p>

          <p class="note">An implementation may choose to use bytes buffered, time buffered, the append rate, or any other metric it sees fit to
            determine when it has enough data. The metrics used may change during playback so web applications should only rely on the value of
            <a def-id="ready-state"></a> to determine whether more data is needed or not.</p>

          <p class="note">When the media element needs more data, it should transition from <a def-id="have-enough-data"></a> to
            <a def-id="have-future-data"></a> early enough for a web application to be able to respond without causing an interruption in playback.
            For example, transitioning when the current playback position is 500ms before the end of the buffered data gives the application roughly
            500ms to append more data before playback stalls.</p>

          <dl class="switch">
            <dt>If <a def-id="buffered"></a> for all objects in <a def-id="activeSourceBuffers"></a> do not contain <a def-id="timeranges"></a> for the current playback position:</dt>
            <dd>
	      <ol>
	        <li>Set the <a def-id="ready-state"></a> attribute to <a def-id="have-metadata"></a>.</li>
	        <li>If this is the first transition to <a def-id="have-metadata"></a>, then <a def-id="queue-a-task-to-fire-an-event-named"></a> <a def-id="loadedmetadata"></a> at the media element.</li>
	        <li>Abort these steps.</li>
	      </ol>
            </dd>
            <dt>If <a def-id="buffered"></a> for all objects in <a def-id="activeSourceBuffers"></a> contain <a def-id="timeranges"></a> that include the current playback position and <a def-id="enough-data"></a>:</dt>
            <dd>
	      <ol>
	        <li>Set the <a def-id="ready-state"></a> attribute to <a def-id="have-enough-data"></a>.</li>
	        <li>
                  <a def-id="Queue-a-task-to-fire-an-event-named"></a> <a def-id="canplaythrough"></a> at the media element.</li>
	        <li>Playback may resume at this point if it was previously suspended by a transition to <a def-id="have-current-data"></a>.</li>
	        <li>Abort these steps.</li>
	      </ol>
            </dd>
            <dt>If <a def-id="buffered"></a> for at least one object in <a def-id="activeSourceBuffers"></a> contains a <a def-id="timerange"></a> that includes the current playback position but not <a def-id="enough-data"></a>:</dt>
            <dd>
	      <ol>
	        <li>Set the <a def-id="ready-state"></a> attribute to <a def-id="have-future-data"></a>.</li>
	        <li>If the previous value of <a def-id="ready-state"></a> was less than <a def-id="have-future-data"></a>, then <a def-id="queue-a-task-to-fire-an-event-named"></a> <a def-id="canplay"></a> at the media element.</li>
	        <li>Playback may resume at this point if it was previously suspended by a transition to <a def-id="have-current-data"></a>.</li>
	        <li>Abort these steps.</li>
	      </ol>
            </dd>
            <dt>If <a def-id="buffered"></a> for at least one object in <a def-id="activeSourceBuffers"></a> contains a <a def-id="timerange"></a> that ends at the current playback position and does not have a range covering the time immediately after the current position:</dt>
            <dd>
	      <ol>
	        <li>Set the <a def-id="ready-state"></a> attribute to <a def-id="have-current-data"></a>.</li>
	        <li>If this is the first transition to <a def-id="have-current-data"></a>, then <a def-id="queue-a-task-to-fire-an-event-named"></a> <a def-id="loadeddata"></a> at the media element.</li>
	        <li>Playback is suspended at this point since the media element doesn't have enough data to advance the timeline.</li>
	        <li>Abort these steps.</li>
	      </ol>
            </dd>
          </dl>
        </section>

        <section id="active-source-buffer-changes">
          <h4>Changes to selected/enabled track state</h4>
          <p>During playback <a def-id="activeSourceBuffers"></a> needs to be updated if the <a def-id="videoref" name="dom-videotrack-selected">selected video track</a>, the <a def-id="videoref" name="dom-audiotrack-enabled">enabled audio tracks</a>, or a text track <a def-id="videoref" name="dom-texttrack-mode">mode</a> changes. When one or more of these changes occur the following steps need to be followed.</p>
          <dl class="switch">
            <dt>If the selected video track changes, then run the following steps:</dt>
            <dd>
	      <ol>
	        <li>If the <a>SourceBuffer</a> associated with the previously selected video track is not associated with any other enabled tracks, run the following steps:
  	          <ol>
	            <li>Remove the <a>SourceBuffer</a> from <a def-id="activeSourceBuffers"></a>.</li>
	            <li>
                      <a def-id="Queue-a-task-to-fire-an-event-named"></a> <a def-id="removesourcebuffer"></a> at <a def-id="activeSourceBuffers"></a>
                    </li>
	          </ol>
	        </li>
	        <li>If the <a>SourceBuffer</a> associated with the newly selected video track is not already in <a def-id="activeSourceBuffers"></a>, run the following steps:
	          <ol>
	            <li>Add the <a>SourceBuffer</a> to <a def-id="activeSourceBuffers"></a>.</li>
	            <li>
                      <a def-id="Queue-a-task-to-fire-an-event-named"></a> <a def-id="addsourcebuffer"></a> at <a def-id="activeSourceBuffers"></a>
                    </li>
	          </ol>
	        </li>
	      </ol>
            </dd>
            <dt>If an audio track becomes disabled and the <a>SourceBuffer</a> associated with this track is not associated with any other enabled or selected track, then run the following steps:</dt>
            <dd>
	      <ol>
	        <li>Remove the <a>SourceBuffer</a> associated with the audio track from <a def-id="activeSourceBuffers"></a>
                </li>
	        <li>
                  <a def-id="Queue-a-task-to-fire-an-event-named"></a> <a def-id="removesourcebuffer"></a> at <a def-id="activeSourceBuffers"></a>
                </li>
	      </ol>
            </dd>
            <dt>If an audio track becomes enabled and the <a>SourceBuffer</a> associated with this track is not already in <a def-id="activeSourceBuffers"></a>, then run the following steps:
            </dt>
            <dd>
	      <ol>
	        <li>Add the <a>SourceBuffer</a> associated with the audio track to <a def-id="activeSourceBuffers"></a>
                </li>
	        <li>
                  <a def-id="Queue-a-task-to-fire-an-event-named"></a> <a def-id="addsourcebuffer"></a> at <a def-id="activeSourceBuffers"></a>
                </li>
	      </ol>
            </dd>
            <dt>If a text track <a def-id="videoref" name="dom-texttrack-mode">mode</a> becomes <a def-id="videoref" name="dom-texttrack-disabled">"disabled"</a> and the <a>SourceBuffer</a> associated with this track is not associated with any other enabled or selected track, then run the following steps:</dt>
            <dd>
	      <ol>
	        <li>Remove the <a>SourceBuffer</a> associated with the text track from <a def-id="activeSourceBuffers"></a>
                </li>
	        <li>
                  <a def-id="Queue-a-task-to-fire-an-event-named"></a> <a def-id="removesourcebuffer"></a> at <a def-id="activeSourceBuffers"></a>
                </li>
	      </ol>
            </dd>
            <dt>If a text track <a def-id="videoref" name="dom-texttrack-mode">mode</a> becomes <a def-id="videoref" name="dom-texttrack-showing">"showing"</a> or <a def-id="videoref" name="dom-texttrack-hidden">"hidden"</a> and the <a>SourceBuffer</a> associated with this track is not already in <a def-id="activeSourceBuffers"></a>, then run the following steps:
            </dt>
            <dd>
	      <ol>
	        <li>Add the <a>SourceBuffer</a> associated with the text track to <a def-id="activeSourceBuffers"></a>
                </li>
	        <li>
                  <a def-id="Queue-a-task-to-fire-an-event-named"></a> <a def-id="addsourcebuffer"></a> at <a def-id="activeSourceBuffers"></a>
                </li>
	      </ol>
            </dd>
          </dl>
        </section>

        <section id="duration-change-algorithm">
          <h4>Duration change</h4>
          <p>Follow these steps when <a def-id="duration"></a> needs to change to a <var>new duration</var>.</p>
          <ol>
            <li>If the current value of <a def-id="duration"></a> is equal to <var>new duration</var>, then abort these steps.</li>
            <li>Set <var>old duration</var> to the current value of <a def-id="duration"></a>.
            <li>Update <a def-id="duration"></a> to <var>new duration</var>.</li>
            <li>If the <var>new duration</var> is less than <var>old duration</var>, then call <code><a href="#widl-SourceBuffer-remove-void-double-start-double-end">remove</a>(<var>new duration</var>, <var>old duration</var>)</code> on all objects in <a def-id="sourceBuffers"></a>.
              <p class="note">This preserves audio frames that start before and end after the <a def-id="duration"></a>. The user agent must end playback at <a def-id="duration"></a> even if the audio frame extends beyond this time.</p>
            </li>

            <li>Update the <a def-id="hme-duration"></a> to <var>new duration</var> and run the <a def-id="hme-duration-change-algorithm"></a>.</li>
          </ol>
        </section>
      </section>
    </section>

    <section id="sourcebuffer">
      <h2>SourceBuffer Object</h2>

      <p class="issue"><a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=20327">Bug 20327</a> - Continuous splice flag</p>

      <dl title="interface SourceBuffer : EventTarget" class="idl">
        <dt>readonly attribute boolean updating</dt>
        <dd>
          <p>Indicates whether an <a def-id="appendArrayBuffer"></a>, <a def-id="appendStream"></a>, or <a def-id="remove"></a> operation is still being
            processed.</p>
        </dd>

        <dt>readonly attribute TimeRanges buffered</dt>
        <dd>
          <p>Indicates what <a def-id="timeranges"></a> are buffered in the <a>SourceBuffer</a>.</p>
          <p>When the attribute is read the following steps must occur:</p>
          <ol>
            <li>If this object has been removed from the <a def-id="sourceBuffers"></a> attribute of the <a def-id="parent-media-source"></a> then throw an <a def-id="invalid-state-err"></a> exception and abort these steps.</li>
            <li>Return a new static <a def-id="normalized-timeranges-object"></a> for the <a def-id="media-segments"></a> buffered.</li>
          </ol>
        </dd>

        <dt>attribute double timestampOffset</dt>
        <dd>
          <p>Controls the offset applied to timestamps inside subsequent <a def-id="media-segments"></a> that are appended to this <a>SourceBuffer</a>. The <a def-id="timestampOffset"></a> is initially set to 0 which indicates that no offset is being applied.</p>
          <p>On getting, Return the initial value or the last value that was successfully set.</p>
          <p>On setting, run the following steps:</p>
          <ol>
            <li>If this object has been removed from the <a def-id="sourceBuffers"></a> attribute of the <a def-id="parent-media-source"></a>, then throw an <a def-id="invalid-state-err"></a> exception and abort these steps.</li>
            <li>If the <a def-id="updating"></a> attribute equals true, then throw an <a def-id="invalid-state-err"></a> exception and abort these steps.</li>
            <li>If the <a def-id="readyState"></a> attribute of the <a def-id="parent-media-source"></a> is not in the <a def-id="open"></a> state, then throw an <a def-id="invalid-state-err"></a> exception and abort these steps.</li>
            <li>If this object is waiting for the end of a <a def-id="media-segment"></a> to be appended, then throw an <a def-id="invalid-state-err"></a> and abort these steps.</li>
            <li>Update the attribute to the new value.</li>
          </ol>
          <p class="issue"><a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=19676">Bug 19676</a> - timestampOffset accuracy</p>
        </dd>

        <dt>readonly attribute AudioTrackList audioTracks</dt>
        <dd>
          The list of <a def-id="audio-track"></a> objects created by this object.
        </dd>

        <dt>readonly attribute VideoTrackList videoTracks</dt>
        <dd>
          The list of <a def-id="video-track"></a> objects created by this object.
        </dd>

        <dt>readonly attribute TextTrackList textTracks</dt>
        <dd>
          The list of <a def-id="text-track"></a> objects created by this object.
        </dd>

        <dt>void appendArrayBuffer(ArrayBuffer data)</dt>
        <dd>
          <p>Appends the segment data in an ArrayBuffer to the source buffer.</p>

          <ol class="method-algorithm">
            <li>If <var>data</var> is null then throw an <a def-id="invalid-access-err"></a> exception and abort these steps.</li>
            <li>If this object has been removed from the <a def-id="sourceBuffers"></a> attribute of the <a def-id="parent-media-source"></a> then throw an <a def-id="invalid-state-err"></a> exception and abort these steps.</li>
            <li>If the <a def-id="updating"></a> attribute equals true, then throw an <a def-id="invalid-state-err"></a> exception and abort these steps.</li>
            <li>If the <a def-id="readyState"></a> attribute of the <a def-id="parent-media-source"></a> is in the <a def-id="closed"></a> state then throw an <a def-id="invalid-state-err"></a> exception and abort these steps.</li>
            <li>
              <p>If the <a def-id="readyState"></a> attribute of the <a def-id="parent-media-source"></a> is in the <a def-id="ended"></a> state then run the following steps:</p>
              <ol>
	        <li>Set the <a def-id="readyState"></a> attribute of the <a def-id="parent-media-source"></a> to <a def-id="open"></a>
                </li>
	        <li>
                  <a def-id="Queue-a-task-to-fire-an-event-named"></a> <a def-id="sourceopen"></a> at the <a def-id="parent-media-source"></a> .</li>
              </ol>
            </li>
            <li>
              <p>If the <a def-id="buffer-full-flag"></a> equals true, then throw a <a def-id="quota-exceeded-err"></a> exception and abort these step.</p>
              <p class="note">The web application must use <a def-id="remove"></a> to free up space in the <a>SourceBuffer</a>.</p>
            </li>
            <li>Add <var>data</var> to the end of the <a def-id="input-buffer"></a>.</li>
            <li>Set the <a def-id="updating"></a> attribute to true.</li>
            <li><a def-id="Queue-a-task-to-fire-an-event-named"></a> <a def-id="updatestart"></a> at this <a>SourceBuffer</a> object.</li>
            <li>Asynchronously run the <a def-id="segment-parser-loop"></a> algorithm.</li>
          </ol>
        </dd>

        <dt>void appendStream(Stream stream, optional unsigned long long maxSize)</dt>
        <dd>
          <p>Appends segment data to the source buffer from a <a def-id="Stream"></a>.</p>

          <ol class="method-algorithm">
            <li>If <var>stream</var> is null then throw an <a def-id="invalid-access-err"></a> exception and abort these steps.</li>
            <li>If this object has been removed from the <a def-id="sourceBuffers"></a> attribute of the <a def-id="parent-media-source"></a> then throw
              an <a def-id="invalid-state-err"></a> exception and abort these steps.</li>
            <li>If the <a def-id="readyState"></a> attribute of the <a def-id="parent-media-source"></a> is in the <a def-id="closed"></a> state then throw
              an <a def-id="invalid-state-err"></a> exception and abort these steps.</li>
            <li>If the <a def-id="updating"></a> attribute equals true, then throw an <a def-id="invalid-state-err"></a> exception and abort these
              steps.</li>
            <li>
              <p>If the <a def-id="readyState"></a> attribute of the <a def-id="parent-media-source"></a> is in the <a def-id="ended"></a> state then run
                the following steps:</p>
              <ol>
	        <li>Set the <a def-id="readyState"></a> attribute of the <a def-id="parent-media-source"></a> to <a def-id="open"></a></li>
	        <li><a def-id="Queue-a-task-to-fire-an-event-named"></a> <a def-id="sourceopen"></a> at the <a def-id="parent-media-source"></a> .</li>
              </ol>
            </li>
            <li>
              <p>If the <a def-id="buffer-full-flag"></a> equals true, then throw a <a def-id="quota-exceeded-err"></a> exception and abort these step.</p>
              <p class="note">The web application must use <a def-id="remove"></a> to free up space in the <a>SourceBuffer</a>.</p>
            </li>
            <li>Set the <a def-id="updating"></a> attribute to true.</li>
            <li><a def-id="Queue-a-task-to-fire-an-event-named"></a> <a def-id="updatestart"></a> at this <a>SourceBuffer</a> object.</li>
            <li>Asynchronously run the <a def-id="stream-append-loop"></a> algorithm with <var>stream</var> and <var>maxSize</var>.</li>
          </ol>
        </dd>

        <dt>void abort()</dt>
        <dd>
          <p>Aborts the current segment and resets the segment parser.</p>

          <ol class="method-algorithm">
            <li>If this object has been removed from the <a def-id="sourceBuffers"></a> attribute of the <a def-id="parent-media-source"></a> then throw an <a def-id="invalid-state-err"></a> exception and abort these steps.</li>
            <li>If the <a def-id="readyState"></a> attribute of the <a def-id="parent-media-source"></a> is not in the <a def-id="open"></a> state then throw an <a def-id="invalid-state-err"></a> exception and abort these steps.</li>
            <li>If the <a def-id="updating"></a> attribute equals true, then run the following steps:
              <ol>
                <li>Abort the <a def-id="stream-append-loop"></a> algorithm if it is running.</li>
                <li>Set the <a def-id="updating"></a> attribute to false.</li>
                <li><a def-id="Queue-a-task-to-fire-an-event-named"></a> <a def-id="updateabort"></a> at this <a>SourceBuffer</a> object.</li>
                <li><a def-id="Queue-a-task-to-fire-an-event-named"></a> <a def-id="updateend"></a> at this <a>SourceBuffer</a> object.</li>
              </ol>
            </li>
            <li>Run the <a def-id="reset-parser-state-algorithm"></a>.</li>
          </ol>
        </dd>

        <dt>void remove(double start, double end)</dt>
        <dd>
          <p>Removes media for a specific time range.</p>

          <ol class="method-algorithm">
            <li>If <var>start</var> is negative or greater than <a def-id="duration"></a>, then throw an <a def-id="invalid-access-err"></a> exception and abort these steps.</li>
            <li>If <var>end</var> is less than or equal to <var>start</var>, then throw an <a def-id="invalid-access-err"></a> exception and abort these steps.</li>
            <li>If this object has been removed from the <a def-id="sourceBuffers"></a> attribute of the <a def-id="parent-media-source"></a> then throw an <a def-id="invalid-state-err"></a> exception and abort these steps.</li>
            <li>If the <a def-id="updating"></a> attribute equals true, then throw an <a def-id="invalid-state-err"></a> exception and abort these steps.</li>
            <li>If the <a def-id="readyState"></a> attribute of the <a def-id="parent-media-source"></a> is not in the <a def-id="open"></a> state then throw an <a def-id="invalid-state-err"></a> exception and abort these steps.</li>
            <li>Set the <a def-id="updating"></a> attribute to true.</li>
            <li><a def-id="Queue-a-task-to-fire-an-event-named"></a> <a def-id="updatestart"></a> at this <a>SourceBuffer</a> object.</li>
            <li>Return control to the caller and run the rest of the steps asynchronously.</li>
            <li>
              <p>For each <a def-id="track-buffer"></a> in this source buffer, run the following steps:</p>
              <ol>
	        <li>Let <var>remove end timestamp</var> be the current value of <a def-id="duration"></a></li>
                <li>
                  <p>If this <a def-id="track-buffer"></a> has a <a def-id="random-access-point"></a> timestamp that is greater than or equal to <var>end</var>, then update <var>remove end timestamp</var> to that timestamp.</p>
	          <p class="note">Random access point timestamps can be different across tracks because the dependencies between <a def-id="coded-frames"></a> within a track are usually different than the dependencies in another track.</p>
                </li>
	        <li>Remove all media data, from this <a def-id="track-buffer"></a>, that contain starting timestamps greater than or equal to <var>start</var> and less than the <var>remove end timestamp</var>.</li>
                <li>
                  <p>If this object is in <a def-id="activeSourceBuffers"></a>, the <a def-id="current-playback-position"></a> is greater than or equal to <var>start</var> and less than the <var>remove end timestamp</var>, and <a def-id="ready-state"></a> is greater than <a def-id="have-metadata"></a>, then set the <a def-id="ready-state"></a> attribute to <a def-id="have-metadata"></a> and stall playback.</p>
                  <p class="note">This transition occurs because media data for the current position has been removed. Playback cannot progress until media for the <a def-id="current-playback-position"></a> is appended or the <a href="#active-source-buffer-changes">selected/enabled tracks change</a>.</p>
                </li>
	      </ol>
            </li>
            <li>If <a def-id="buffer-full-flag"></a> equals true and this object is ready to accept more bytes, then set 
              the <a def-id="buffer-full-flag"></a> to false.</li>
            <li>Set the <a def-id="updating"></a> attribute to false.</li>
            <li><a def-id="Queue-a-task-to-fire-an-event-named"></a> <a def-id="updateend"></a> at this <a>SourceBuffer</a> object.</li>
       </ol>

        </dd>
      </dl>

      <section id="track-buffers">
        <h3>Track Buffers</h3>
        <p>A <dfn id="track-buffer">track buffer</dfn> stores the <a def-id="track-descriptions"></a> and <a def-id="coded-frames"></a> for an individual
          track. The track buffer is updated as <a def-id="init-segments"></a> and <a def-id="media-segments"></a> are appended to the 
          <a>SourceBuffer</a>.</p>

        <p>Each <a def-id="track-buffer"></a> has a <dfn id="last-decode-timestamp">last decode timestamp</dfn> variable that stores
          the decode timestamp of the last <a def-id="coded-frame"></a> appended in the current <a def-id="append-sequence"></a>. The variable is initially
          unset to indicate that no <a def-id="coded-frames"></a> have been appended yet.</p>

        <p>Each <a def-id="track-buffer"></a> has a <dfn id="highest-presentation-timestamp">highest presentation timestamp</dfn> variable that stores
          the highest presentation timestamp encountered in a <a def-id="coded-frame"></a> appended in the current <a def-id="append-sequence"></a>.
          The variable is initially unset to indicate that no <a def-id="coded-frames"></a> have been appended yet.</p>
      </section>

      <section id="sourcebuffer-events">
        <h3>Event Summary</h3>
        <table class="old-table">
          <thead>
            <tr>
              <th>Event name</th>
              <th>Interface</th>
              <th>Dispatched when...</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><a def-id="eventdfn">updatestart</a></td>
              <td><code>Event</code></td>
              <td><a def-id="updating"></a> transitions from false to true.</td>
            </tr>
            <tr>
              <td><a def-id="eventdfn">updateend</a></td>
              <td><code>Event</code></td>
              <td><a def-id="updating"></a> transitions from true to false.</td>
            </tr>
            <tr>
              <td><a def-id="eventdfn">error</a></td>
              <td><code>Event</code></td>
              <td>An error occurred during the append.</td>
            </tr>
            <tr>
              <td><a def-id="eventdfn">abort</a></td>
              <td><code>Event</code></td>
              <td>The append or remove was aborted by an <a def-id="abort"></a> call.</td>
            </tr>
          </tbody>
        </table>
      </section>

      <section id="sourcebuffer-algorithms">
        <h3>Algorithms</h3>

        <section id="sourcebuffer-segment-parser-loop">
          <h4>Segment Parser Loop</h4>
          <p>All SourceBuffer objects have an internal <dfn id="sourcebuffer-append-state">append state</dfn> variable that keeps track of the high-level segment parsing state. It is initially set to <a def-id="waiting-for-segment"></a> and can transition to the following states as data is appended.</p>
          <table class="old-table">
            <thead>
	      <tr>
                <th>Append state name</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><dfn id="sourcebuffer-waiting-for-segment">WAITING_FOR_SEGMENT</dfn></td>
                <td>Waiting for the start of an <a def-id="init-segment"></a> or <a def-id="media-segment"></a> to be appended.</td>
              </tr>
              <tr>
                <td><dfn id="sourcebuffer-parsing-init-segment">PARSING_INIT_SEGMENT</dfn></td>
                <td>Currently parsing an <a def-id="init-segment"></a>.</td>
              </tr>
	      <tr>
	        <td><dfn id="sourcebuffer-parsing-media-segment">PARSING_MEDIA_SEGMENT</dfn></td>
                <td>Currently parsing a <a def-id="media-segment"></a>.</td>
              </tr>
            </tbody>
          </table>
          
          <p>The <dfn id="sourcebuffer-input-buffer">input buffer</dfn> is a byte buffer that is used to hold unparsed bytes across <a def-id="appendArrayBuffer"></a> and <a def-id="appendStream"></a> calls. The buffer is empty when the SourceBuffer object is created.</p>

          <p>The <dfn id="sourcebuffer-buffer-full-flag">buffer full flag</dfn> keeps track of whether <a def-id="appendArrayBuffer"></a> or 
            <a def-id="appendStream"></a> is allowed to accept more bytes. It is set to false when the SourceBuffer object is created and gets updated 
            as data is appended and removed.</p>

          <p>When this algorithm is invoked, run the following steps:</p>

          <ol>
            <li><i>Loop Top:</i> If the <a def-id="input-buffer"></a> is empty, then jump to the <i>need more data</i> step below.</li>
            <li>If the <a def-id="input-buffer"></a> starts with bytes that violate the <a def-id="byte-stream-format-specs"></a>, then run the <a def-id="append-error-algorithm"></a> and abort this algorithm.</li>
            <li>Remove any bytes that the <a def-id="byte-stream-format-specs"></a> say should be ignored from the start of the <a def-id="input-buffer"></a>.</li>
            <li>
	      <p>If the <a def-id="append-state"></a> equals <a def-id="waiting-for-segment"></a>, then run the following steps:</p>
	      <ol>
	        <li>If the beginning of the <a def-id="input-buffer"></a> indicates the start of an <a def-id="init-segment"></a>, set the <a def-id="append-state"></a> to <a def-id="parsing-init-segment"></a>.</li>
	        <li>If the beginning of the <a def-id="input-buffer"></a> indicates the start of an <a def-id="media-segment"></a>, set <a def-id="append-state"></a> to <a def-id="parsing-media-segment"></a>.</li>
	        <li>Jump to the <i>loop top</i> step above.</li>
	      </ol>
            </li>
            <li>
	      <p>If the <a def-id="append-state"></a> equals <a def-id="parsing-init-segment"></a>, then run the following steps:</p>
	      <ol>
	        <li>If the <a def-id="input-buffer"></a> does not contain a complete <a def-id="init-segment"></a> yet, then jump to the <i>need more data</i> step below.</li>
	        <li>Run the <a def-id="init-segment-received-algorithm"></a>.</li>
	        <li>Remove the <a def-id="init-segment"></a> bytes from the beginning of the <a def-id="input-buffer"></a>.</li>
	        <li>Set <a def-id="append-state"></a> to <a def-id="waiting-for-segment"></a>.</li>
	        <li>Jump to the <i>loop top</i> step above.</li>
	      </ol>
            </li>
            <li>
	      <p>If the <a def-id="append-state"></a> equals <a def-id="parsing-media-segment"></a>, then run the following steps:</p>
	      <ol>
                <li>If the <a def-id="first-init-segment-flag"></a> is false, then run the <a def-id="append-error-algorithm"></a> and abort this algorithm.</li>
	        <li>
	          <p>If the <a def-id="input-buffer"></a> does not contain a complete <a def-id="media-segment"></a> header yet, then jump to the <i>need more data</i> step below.</p>
	          <p class="note">Implementations may choose to implement this state as an incremental parser so that it is not necessary to have the entire media segment before running the <a def-id="coded-frame-processing-algorithm"></a>.</p>
	        </li>
	        <li>Run the <a def-id="coded-frame-processing-algorithm"></a>.</li>
	        <li>Remove the <a def-id="media-segment"></a> bytes from the beginning of the <a def-id="input-buffer"></a>.</li>
                <li>If this <a>SourceBuffer</a> is full and cannot accept more media data, then set the <a def-id="buffer-full-flag"></a> to true.</li>
	        <li>
	          <p>Set <a def-id="append-state"></a> to <a def-id="waiting-for-segment"></a>.</p>
	          <p class="note">Incremental parsers should only do this transition after the entire media segment has been received.</p>
	        </li>
	        <li>Jump to the <i>loop top</i> step above.</li>
	      </ol>
            </li>
            <li><i>Need more data:</i> If the <a def-id="stream-append-loop"></a> algorithm is running and still has data to read, then abort these steps.
            <li>Set the <a def-id="updating"></a> attribute to false.</li>
            <li><a def-id="Queue-a-task-to-fire-an-event-named"></a> <a def-id="updateend"></a> at this <a>SourceBuffer</a> object.</li>
          </ol>
        </section>

        <section id="sourcebuffer-reset-parser-state">
          <h4>Reset Parser State</h4>
          <p>When the parser state needs to be reset, run the following steps:</p>
          <ol>
            <li>If the <a def-id="append-state"></a> equals <a def-id="parsing-media-segment"></a> and the <a def-id="input-buffer"></a> contains some complete <a def-id="coded-frames"></a>, then run the <a def-id="coded-frame-processing-algorithm"></a> as if the media segment only contained these frames.</li>
            <li>Unset the <a def-id="last-decode-timestamp"></a> on all <a def-id="track-buffers"></a>.</li>
            <li>Unset the <a def-id="highest-presentation-timestamp"></a> on all <a def-id="track-buffers"></a>.</li>
            <li>Remove all bytes from the <a def-id="input-buffer"></a>.</li>
            <li>Set <a def-id="append-state"></a> to <a def-id="waiting-for-segment"></a>.</li>
          </ol>
        </section>

        <section id="sourcebuffer-append-error">
          <h4>Append Error</h4>
          <p>When an error occurs during an append, run the following steps:</p>
          <ol>
            <li>Run the <a def-id="reset-parser-state-algorithm"></a>.</li>
            <li>Abort the <a def-id="stream-append-loop"></a> algorithm if it is running.</li>
            <li>Set the <a def-id="updating"></a> attribute to false.</li>
            <li>
              <a def-id="Queue-a-task-to-fire-an-event-named"></a> <a def-id="updateerror"></a> at this <a>SourceBuffer</a> object.
              <p class="issue">Need a way to convey error information.</p>
            </li>
            <li><a def-id="Queue-a-task-to-fire-an-event-named"></a> <a def-id="updateend"></a> at this <a>SourceBuffer</a> object.</li>
          </ol>
        </section>

        <section id="sourcebuffer-stream-append-loop">
          <h4>Stream Append Loop</h4>
          <p>When a <a def-id="Stream"></a> is passed to <a def-id="appendStream"></a>, the following steps are run to transfer data from the
            <a def-id="Stream"></a> to the <a>SourceBuffer</a>. This algorithm is initialized with the  <var>stream</var> and <var>maxSize</var> parameters
            from the <a def-id="appendStream"></a> call.
          </p>
          <ol>
            <li>If <var>maxSize</var> is set, then let <var>bytesLeft</var> equal <var>maxSize</var>.</li>
            <li><i>Loop Top: </i>If <var>maxSize</var> is set and <var>bytesLeft</var> equals 0, then jump to the <i>loop done</i> step below.</li>
            <li>If <var>stream</var> has been aborted, then run the <a def-id="append-error-algorithm"></a> and abort this algorithm.</li>
            <li>If <var>stream</var> has been closed, then jump to the <i>loop done</i> step below.</li>
            <li>
              <p>If the <a def-id="buffer-full-flag"></a> equals true, then run the <a def-id="append-error-algorithm"></a> and abort this algorithm.</p>
              <p class="note">The web application must use <a def-id="remove"></a> to free up space in the <a>SourceBuffer</a>.</p>
            </li>
            <li>Read data from <var>stream</var> into <var>data</var>:
              <dl class="switch">
                <dt>If <var>maxSize</var> is set:</dt>
                <dd>
                  <ol>
                    <li>Read up to <var>bytesLeft</var> bytes from <var>stream</var> into <var>data</var>.</li>
                    <li>Subtract the number of bytes in <var>data</var> from <var>bytesLeft</var>.</li>
                </dd>
                <dt>Otherwise:</dt>
                <dd>Read all available bytes in <var>stream</var> into <var>data</var>.</dd>
              </dl>
            </li>
            <li>If an error occured while reading from <var>stream</var>, then run the <a def-id="append-error-algorithm"></a> and abort this algorithm.</li>
            <li>Add <var>data</var> to the end of the <a def-id="input-buffer"></a>.</li>
            <li>Run the <a def-id="segment-parser-loop"></a> algorithm.</li>
            <li>Jump to the <i>loop top</i> step above.</li>
            <li><i>Loop Done: </i>Set the <a def-id="updating"></a> attribute to false.</li>
            <li><a def-id="Queue-a-task-to-fire-an-event-named"></a> <a def-id="updateend"></a> at this <a>SourceBuffer</a> object.</li>
          </ol>
        </section>

        <section id="sourcebuffer-init-segment-received">
          <h4>Initialization Segment Received</h4>
          <p>The following steps are run when the <a def-id="segment-parser-loop"></a> successfully parses a complete <a def-id="init-segment"></a>:</p>
          <p>Each SourceBuffer object has an internal <dfn id="first-init-segment-flag">first initialization segment flag</dfn> that tracks whether the first <a def-id="init-segment"></a> has been appended. This flag is set to false when the SourceBuffer is created and updated by the algorithm below.</p>
          <ol>
            <li>Update the <a def-id="duration"></a> attribute if it currently equals NaN:
              <dl class="switch">
	        <dt>If the initialization segment contains a duration:</dt>
	        <dd>Run the <a def-id="duration-change-algorithm"></a> with <var>new duration</var> set to the duration in the initialization segment.</dd>
	        <dt>Otherwise:</dt>
	        <dd>Run the <a def-id="duration-change-algorithm"></a> with <var>new duration</var> set to positive Infinity.</dd>
              </dl>
            </li>
            <li>If the <a def-id="init-segment"></a> has no audio, video, or text tracks, then call <a def-id="eos-decode"></a> and abort these steps.</li>
            <li>If the <a def-id="first-init-segment-flag"></a> is true, then run the following steps:
              <ol>
                <li>Verify the following properties. If any of the checks fail then call <a def-id="eos-decode"></a> and abort these steps.
                  <ul>
                    <li>The number of audio, video, and text tracks match what was in the first <a def-id="init-segment"></a>.</li>
                    <li>The codecs for each track, match what was specified in the first <a def-id="init-segment"></a>.</li>
                    <li>If more than one track for a single type are present (ie 2 audio tracks), then the <a def-id="track-ids"></a> match the ones in the
                      first <a def-id="init-segment"></a>.</li>
                  </ul>
                </li>
                <li>Add the appropriate <a def-id="track-descriptions"></a> from this <a def-id="init-segment"></a> to each of the 
                  <a def-id="track-buffers"></a>.</li>
              </ol>
            </li>
            <li>Let <var>active track flag</var> equal false.</li>
            <li>
              <p>If the <a def-id="first-init-segment-flag"></a> is false, then run the following steps:</p>
              <ol>
                <li>
                  <p>For each audio track in the <a def-id="init-segment"></a>, run following steps:</p>
                  <ol>
                    <li>Let <var>new audio track</var> be a new <a def-id="audio-track"></a> object.</li>
                    <li>Generate a unique ID and assign it to the <a def-id="audiotrack-id"></a> property on <var>new audio track</var>.</li>
                    <li>
                      <p>
                        If <a def-id="audiotracks"></a>.<a def-id="audiotracklist-length"></a> equals 0, then run
                          the following steps:
                      </p>
                      <ol>
                        <li>Set the <a def-id="audiotrack-enabled"></a> property on <var>new audio track</var> to true.</li>
                        <li>Set <var>active track flag</var> to true.</li>
                      </ol>
                    </li>
                    <li>Add <var>new audio track</var> to the <a def-id="sourcebuffer-audioTracks"></a> attribute on this <a>SourceBuffer</a> object.</li>
                    <li>Add <var>new audio track</var> to the <a def-id="audiotracks"></a> attribute on the HTMLMediaElement.</li>
                    <li>Create a new <a def-id="track-buffer"></a> to store <a def-id="coded-frames"></a> for this track.</li>
                    <li>Add the <a def-id="track-description"></a> for this track to the <a def-id="track-buffer"></a>.</li>
                  </ol>
                </li>
                <li>
                  <p>For each video track in the <a def-id="init-segment"></a>, run following steps:</p>
                  <ol>
                    <li>Let <var>new video track</var> be a new <a def-id="video-track"></a> object.</li>
                    <li>Generate a unique ID and assign it to the <a def-id="videotrack-id"></a> property on <var>new video track</var>.</li>
                    <li>
                      <p>
                        If <a def-id="videotracks"></a>.<a def-id="videotracklist-length"></a> equals 0, then run
                          the following steps:
                      </p>
                      <ol>
                        <li>Set the <a def-id="videotrack-selected"></a> property on <var>new video track</var> to true.</li>
                        <li>Set <var>active track flag</var> to true.</li>
                      </ol>
                    </li>
                    <li>Add <var>new video track</var> to the <a def-id="sourcebuffer-videoTracks"></a> attribute on this <a>SourceBuffer</a> object.</li>
                    <li>Add <var>new video track</var> to the <a def-id="videotracks"></a> attribute on the HTMLMediaElement.</li>
                    <li>Create a new <a def-id="track-buffer"></a> to store <a def-id="coded-frames"></a> for this track.</li>
                    <li>Add the <a def-id="track-description"></a> for this track to the <a def-id="track-buffer"></a>.</li>
                  </ol>
                </li>
                <li>
                  <p>For each text track in the <a def-id="init-segment"></a>, run following steps:</p>
                  <ol>
                    <li>
                      Let <var>new text track</var> be a new <a def-id="text-track"></a> object with its properties populated with the appropriate
                      information from the <a def-id="init-segment"></a>.</li>
                    <li>
                      If the <a def-id="texttrack-mode"></a> property on <var>new text track</var> equals <a def-id="texttrack-showing"></a> or
                      <a def-id="texttrack-hidden"></a>, then set <var>active track flag</var> to true.
                    </li>
                    <li>Add <var>new text track</var> to the <a def-id="sourcebuffer-textTracks"></a> attribute on this <a>SourceBuffer</a> object.</li>
                    <li>Add <var>new text track</var> to the <a def-id="texttracks"></a> attribute on the HTMLMediaElement.</li>
                    <li>Create a new <a def-id="track-buffer"></a> to store <a def-id="coded-frames"></a> for this track.</li>
                    <li>Add the <a def-id="track-description"></a> for this track to the <a def-id="track-buffer"></a>.</li>
                  </ol>
                </li>
                <li>If <var>active track flag</var> equals true, then run the following steps:
                  <ol>
                    <li>Add this <a>SourceBuffer</a> to <a def-id="activeSourceBuffers"></a>.</li>
                    <li><a def-id="Queue-a-task-to-fire-an-event-named"></a> <a def-id="addsourcebuffer"></a> at <a def-id="activeSourceBuffers"></a></li>
                  </ol>
                </li>
                <li>Set <a def-id="first-init-segment-flag"></a> to true.</li>
              </ol>
            </li>
            <li>
              <p>If the <a def-id="ready-state"></a> attribute is <a def-id="have-nothing"></a>, then run the following steps:</p>
              <ol>
                <li>
                  If one or more objects in <a def-id="sourceBuffers"></a> have <a def-id="first-init-segment-flag"></a> set to false, then abort
                  these steps.</li>
                <li>Set the <a def-id="ready-state"></a> attribute to <a def-id="have-metadata"></a>.</li>
	        <li><a def-id="Queue-a-task-to-fire-an-event-named"></a>  <a def-id="loadedmetadata"></a> at the media element.</li>
              </ol>
            </li>
            <li>
              If the <var>active track flag</var> equals true and the <a def-id="ready-state"></a> attribute is greater than
              <a def-id="have-current-data"></a>, then set the <a def-id="ready-state"></a> attribute to <a def-id="have-metadata"></a>.
            </li>
          </ol>
        </section>

        <section id="sourcebuffer-coded-frame-processing">
          <h4>Coded Frame Processing</h4>
          <p>When complete <a def-id="coded-frames"></a> have been parsed by the <a def-id="segment-parser-loop"></a> then the following steps are run:</p>
          <ol>
            <li>
	      <p>For each <a def-id="coded-frame"></a> in the <a def-id="media-segment"></a> run the following steps:</p>
	      <ol>
	        <li>Let <var>presentation timestamp</var> be a double precision floating point representation of the coded frame's presentation timestamp.</li>
	        <li>Let <var>decode timestamp</var> be a double precision floating point representation of the coded frame's decode timestamp.
                  <p class="note">Implementations don't have to internally store timestamps in a double precision floating point representation. This
                    representation is used here because it is the represention for timestamps in the HTML spec. The intention here is to make the
                    behavior clear without adding unnecessary complexity to the algorithm to deal with the fact that adding a timestampOffset may
                    cause a timestamp rollover in the underlying timestamp representation used by the bytestream format. Implementations can use any
                    internal timestamp representation they wish, but the addition of timestampOffset should behave in a similar manner to what would happen
                    if a double precision floating point representation was used.
                  </p>
                </li>
	        <li>
	          <p>If <a def-id="timestampOffset"></a> is not 0, then run the following steps:</p>
	          <ol>
	            <li>Add <a def-id="timestampOffset"></a> to the <var>presentation timestamp</var>.</li>
	            <li>Add <a def-id="timestampOffset"></a> to the <var>decode timestamp</var>.</li>
	            <li>If the <var>presentation timestamp</var> or <var>decode timestamp</var> is less than the <a def-id="presentation-start-time"></a>, then call <a def-id="eos-decode"></a>, and abort these steps.</li>
	          </ol>
	        </li>
                <li>Let <var>track buffer</var> equal the <a def-id="track-buffer"></a> that the coded frame should be added to.</li>
                <li>If <a def-id="last-decode-timestamp"></a> for <var>track buffer</var> is set and <var>decode timestamp</var> is less than
                  <a def-id="last-decode-timestamp"></a> or the difference between <var>decode timestamp</var> and <a def-id="last-decode-timestamp"></a>
                  is greater than 100 milliseconds, then call <a def-id="eos-decode"></a> and abort these steps.
                  <p class="note">These checks trigger an error when the application attempts out-of-order appends without an intervening
                    <a def-id="abort"></a>.</p>
                </li>

                <li>If <a def-id="highest-presentation-timestamp"></a> for <var>track buffer</var> is set and less than <var>presentation timestamp</var>,
                  then run the following steps:
                  <ol>
                    <li>Remove all <a def-id="coded-frames"></a> from <var>track buffer</var> that have a presentation timestamp greater than
                      <a def-id="highest-presentation-timestamp"></a> and less than or equal to <var>presentation timestamp</var>.</li>
                    <li>Remove all <a def-id="coded-frames"></a> from <var>track buffer</var> that have decoding dependencies on the coded frames removed in
                      the previous step.
                      <p class="note">For example if an I-frame is removed in the previous step, then all P-frames & B-frames that depend on that I-frame
                       should be removed from <var>track buffer</var>. This makes sure that decode dependencies are properly maintained during overlaps.</p>
                    </li>
                    </li>
                  </ol>
                </li>
	        <li>Add the <a def-id="coded-frame"></a> with the <var>presentation timestamp</var> and <var>decode timestamp</var>, to the
                  <var>track buffer</var>.</li>
                <li>Set <a def-id="last-decode-timestamp"></a> for <var>track buffer</var> to <var>decode timestamp</var>.</li>
                <li>If <a def-id="highest-presentation-timestamp"></a> for <var>track buffer</var> is unset or <var>presentation timestamp</var> is greater
                  than <a def-id="highest-presentation-timestamp"></a>, then set <a def-id="highest-presentation-timestamp"></a> for <var>track buffer</var>
                  to <var>presentation timestamp</var>.
                  <p class="note">The greater than check is needed because bidirectional prediction between coded frames can cause
                    <var>presentation timestamp</var> to not be monotonically increasing eventhough the decode timestamps are monotonically increasing.</p>
                </li>
	      </ol>
            </li>
            <li>
              <p>If the <a def-id="ready-state"></a> attribute is <a def-id="have-metadata"></a> and the new <a def-id="coded-frames"></a> cause all objects in <a def-id="activeSourceBuffers"></a> to have media data for the current playback position, then run the following steps:</p>
	      <ol>
	        <li>Set the <a def-id="ready-state"></a> attribute to <a def-id="have-current-data"></a>.</li>
	        <li>If this is the first transition to <a def-id="have-current-data"></a>, then <a def-id="queue-a-task-to-fire-an-event-named"></a> <a def-id="loadeddata"></a> at the media element.</li>
	      </ol>
            </li>
            <li>
	      <p>If the <a def-id="ready-state"></a> attribute is <a def-id="have-current-data"></a> and the new <a def-id="coded-frames"></a> cause all objects in <a def-id="activeSourceBuffers"></a> to have media data beyond the current playback position, then run the following steps:</p>
	      <ol>
	        <li>Set the <a def-id="ready-state"></a> attribute to <a def-id="have-future-data"></a>.</li>
	        <li>
                  <a def-id="Queue-a-task-to-fire-an-event-named"></a> <a def-id="canplay"></a> at the media element.</li>
	      </ol>
            </li>
            <li>
	      <p>If the <a def-id="ready-state"></a> attribute is <a def-id="have-future-data"></a> and the new <a def-id="coded-frames"></a> cause all objects in <a def-id="activeSourceBuffers"></a> to have <a def-id="enough-data"></a>, then run the following steps:</p>
	      <ol>
	        <li>Set the <a def-id="ready-state"></a> attribute to <a def-id="have-enough-data"></a>.</li>
	        <li>
                  <a def-id="Queue-a-task-to-fire-an-event-named"></a> <a def-id="canplaythrough"></a> at the media element.</li>
	      </ol>
            </li>
            <li>If the <a def-id="media-segment"></a> contains data beyond the current <a def-id="duration"></a>, then run the <a def-id="duration-change-algorithm"></a> with <var>new duration</var> set to the maximum of the current duration and the highest end timestamp reported by <a def-id="hme-buffered"></a>.</li>
          </ol>
        </section>
      </section>
    </section>

    <section id="sourcebufferlist">
      <h2>SourceBufferList Object</h2>
      <p>SourceBufferList is a simple container object for <a>SourceBuffer</a> objects. It provides read-only array access and fires events when the list is modified.</p>

      <dl title="interface SourceBufferList : EventTarget" class="idl">
        <dt>readonly attribute unsigned long length</dt>
        <dd>
          <p>Indicates the number of <a>SourceBuffer</a> objects in the list.</p>
        </dd>
        <dt>getter SourceBuffer (unsigned long index)</dt>
        <dd>
          <p>Allows the SourceBuffer objects in the list to be accessed with an array operator (i.e. []).</p>

          <ol class="method-algorithm">
            <li>If <var>index</var> is greater than or equal to the <a def-id="length"></a> attribute then return undefined and abort these steps.</li>
            <li>Return the <var>index</var>'th <a>SourceBuffer</a> object in the list.</li>
          </ol>
        </dd>
      </dl>

      <section id="sourcebufferlist-events">
        <h3>Event Summary</h3>
        <table class="old-table">
          <thead>
            <tr>
              <th>Event name</th>
              <th>Interface</th>
              <th>Dispatched when...</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><a def-id="eventdfn">addsourcebuffer</a></td>
              <td><code>Event</code></td>
              <td>When a <a>SourceBuffer</a> is added to the list.</td>
            </tr>
            <tr>
              <td><a def-id="eventdfn">removesourcebuffer</a></td>
              <td><code>Event</code></td>
              <td>When a <a>SourceBuffer</a> is removed from the list.</td>
            </tr>
          </tbody>
        </table>
      </section>
    </section>

    <section id="url">
      <h2>URL Object</h2>
      <p></p>

      <dl title="partial interface URL" class="idl">
        <dt>static DOMString createObjectURL(MediaSource mediaSource)</dt>
        <dd>
          <p>Creates URLs for <a>MediaSource</a> objects.</p>

          <ol class="method-algorithm">
            <li>If <var>mediaSource</var> is NULL the return null.</li>
            <li>Return a unique <a def-id="MediaSource-object-URL"></a> that can be used to dereference the <var>mediaSource</var> argument, and run the rest of the algorithm asynchronously.</li>
            <li><a def-id="provide-a-stable-state"></a></li>
            <li>Revoke the <a def-id="MediaSource-object-URL"></a> by calling <a def-id="file-revokeObjectURL"></a> on it.</li>
          </ol>
          <p class="note">This algorithm is intended to mirror the behavior of the <a def-id="FileAPI"></a> <a def-id="file-createObjectURL"></a> method with autoRevoke set to true.</p>
        </dd>
      </dl>
    </section>

    <section id="htmlmediaelement-attributes">
      <h2>HTMLMediaElement attributes</h2>
      <p>This section specifies what existing attributes on the <a def-id="videoref" name="htmlmediaelement">HTMLMediaElement</a> should return when a <a>MediaSource</a> is attached to the element.</p>

      <p>The <a def-id="videoref" name="dom-media-seekable">HTMLMediaElement.seekable</a> attribute returns a new static <a def-id="normalized-timeranges-object"></a> created based on the following steps:</p>
      <dl class="switch">
        <dt>If <a def-id="duration"></a> equals NaN</dt>
        <dd>Return an empty <a def-id="timeranges"></a> object.</dd>
        <dt>If <a def-id="duration"></a> equals positive Infinity</dt>
        <dd>Return a single range with a start time of 0 and an end time equal to the highest end time reported by the <a def-id="hme-buffered"></a> attribute.</dd>
        <dt>Otherwise</dt>
        <dd>Return a single range with a start time of 0 and an end time equal to <a def-id="duration"></a>.</dd>
      </dl>

      <p id="dom-htmlmediaelement.buffered">The <a def-id="hme-buffered"></a> attribute returns a new static <a def-id="normalized-timeranges-object"></a> created based on the following steps:</p>
      <ol>
        <li>If <a def-id="activeSourceBuffers"></a>.length equals 0 then return an empty <a def-id="timeranges"></a> object and abort these steps.</li>
        <li>Let <var>active ranges</var> be the ranges returned by <a def-id="buffered"></a> for each <a>SourceBuffer</a> object in <a def-id="activeSourceBuffers"></a>.</li>
        <li>Let <var>highest end time</var> be the largest range end time in the <var>active ranges</var>.</li>
        <li>Let <var>intersection ranges</var> equal a <a def-id="timerange"></a> object containing a single range from 0 to <var>highest end time</var>.</li>
        <li>For each <a>SourceBuffer</a> object in <a def-id="activeSourceBuffers"></a> run the following steps:
          <ol>
            <li>Let <var>source ranges</var> equal the ranges returned by the <a def-id="buffered"></a> attribute on the current <a>SourceBuffer</a>.</li>
            <li>If <a def-id="readyState"></a> is <a def-id="ended"></a>, then set the end time on the last range in <var>source ranges</var> to 
              <var>highest end time</var>.</li>
            <li>Let <var>new intersection ranges</var> equal the the intersection between the <var>intersection ranges</var> and the <var>source ranges</var>.</li>
            <li>Replace the ranges in <var>intersection ranges</var> with the <var>new intersection ranges</var>.</li>
          </ol>
        </li>
        <li>Return the <var>intersection ranges</var>.</li>
      </ol>
      <p class="issue"><a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=18615">Bug 18615</a> - Define how SourceBuffer.buffered maps to HTMLMediaElement.buffered</p>
      <p class="issue"><a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=18400">Bug 18400</a> - Define and document timestamp heuristics</p>
    </section>

    <section id="audio-track-extensions">
      <h2>AudioTrack Extensions</h2>
      <p>This section specifies extensions to the HTML <a def-id="audio-track"></a> definition.</p>

      <dl title="partial interface AudioTrack" class="idl">
        <dt>attribute DOMString kind</dt>
        <dd>
          <p>Allows the web application to get and update the track <a def-id="audiotrack-kind"></a>.</p>
          <p>On getting, return the current value of the attribute. This is either the value provided when this object was created or the value provided on
            the last successful set operation.<p>
          <p>On setting, run the following steps:</p>
          <ol>
            <li>If the value being assigned to this attribute does not match one of the <a def-id="videoref" name="dom-TrackList-getKind-categories">kind categories</a>, then abort these steps.</li>
            <li>Update this attribute to the new value.</li>
            <li>If the <a def-id="audiotrack-sourceBuffer"></a> attribute on this track is not null, then
              <a def-id="queue-a-task-to-fire-an-event-named"></a> <a def-id="tracklist-change"></a> at
              <a def-id="audiotrack-sourceBuffer"></a>.<a def-id="sourcebuffer-audioTracks"></a>.
            </li>
            <li><a def-id="Queue-a-task-to-fire-an-event-named"></a> <a def-id="tracklist-change"></a> at the <a def-id="audiotracks"></a> attribute on the
              HTMLMediaElement.
            </li>
          </ol>
        </dd>

        <dt>attribute DOMString language</dt>
        <dd>
          <p>Allows the web application to get and update the track <a def-id="audiotrack-language"></a>.</p>
          <p>On getting, return the current value of the attribute. This is either the value provided when this object was created or the value provided on
            the last successful set operation.<p>
          <p>On setting, run the following steps:</p>
          <ol>
            <li>If the value being assigned to this attribute is not an empty string or a BCP 47 language tag[[BCP47]], then abort these steps.</li>
            <li>Update this attribute to the new value.</li>
            <li>If the <a def-id="audiotrack-sourceBuffer"></a> attribute on this track is not null, then
              <a def-id="queue-a-task-to-fire-an-event-named"></a> <a def-id="tracklist-change"></a> at
              <a def-id="audiotrack-sourceBuffer"></a>.<a def-id="sourcebuffer-audioTracks"></a>.
            </li>
            <li><a def-id="Queue-a-task-to-fire-an-event-named"></a> <a def-id="tracklist-change"></a> at the <a def-id="audiotracks"></a> attribute on the
              HTMLMediaElement.
            </li>
          </ol>
        </dd>

        <dt>readonly attribute SourceBuffer? sourceBuffer</dt>
        <dd>
          <p>Returns the <a>SourceBuffer</a> that created this track. Returns null if this track was not created by a <a>SourceBuffer</a> or the <a>SourceBuffer</a> has been removed from the <a def-id="sourceBuffers"></a> attribute of its <a def-id="parent-media-source"></a>.</p>
        </dd>
      </dl>
    </section>

    <section id="video-track-extensions">
      <h2>VideoTrack Extensions</h2>
      <p>This section specifies extensions to the HTML <a def-id="video-track"></a> definition.</p>

      <dl title="partial interface VideoTrack" class="idl">
        <dt>attribute DOMString kind</dt>
        <dd>
          <p>Allows the web application to get and update the track <a def-id="videotrack-kind"></a>.</p>
          <p>On getting, return the current value of the attribute. This is either the value provided when this object was created or the value provided on
            the last successful set operation.<p>
          <p>On setting, run the following steps:</p>
          <ol>
            <li>If the value being assigned to this attribute does not match one of the <a def-id="videoref" name="dom-TrackList-getKind-categories">kind categories</a>, then abort these steps.</li>
            <li>Update this attribute to the new value.</li>
            <li>If the <a def-id="videotrack-sourceBuffer"></a> attribute on this track is not null, then
              <a def-id="queue-a-task-to-fire-an-event-named"></a> <a def-id="tracklist-change"></a> at
              <a def-id="videotrack-sourceBuffer"></a>.<a def-id="sourcebuffer-videoTracks"></a>.
            </li>
            <li><a def-id="Queue-a-task-to-fire-an-event-named"></a> <a def-id="tracklist-change"></a> at the <a def-id="videotracks"></a> attribute on the
              HTMLMediaElement.
            </li>
          </ol>
        </dd>

        <dt>attribute DOMString language</dt>
        <dd>
          <p>Allows the web application to get and update the track <a def-id="videotrack-language"></a>.</p>
          <p>On getting, return the current value of the attribute. This is either the value provided when this object was created or the value provided on
            the last successful set operation.<p>
          <p>On setting, run the following steps:</p>
          <ol>
            <li>If the value being assigned to this attribute is not an empty string or a BCP 47 language tag[[BCP47]], then abort these steps.</li>
            <li>Update this attribute to the new value.</li>
            <li>If the <a def-id="videotrack-sourceBuffer"></a> attribute on this track is not null, then
              <a def-id="queue-a-task-to-fire-an-event-named"></a> <a def-id="tracklist-change"></a> at
              <a def-id="videotrack-sourceBuffer"></a>.<a def-id="sourcebuffer-videoTracks"></a>.
            </li>
            <li><a def-id="Queue-a-task-to-fire-an-event-named"></a> <a def-id="tracklist-change"></a> at the <a def-id="videotracks"></a> attribute on the
              HTMLMediaElement.
            </li>
          </ol>
        </dd>

        <dt>readonly attribute SourceBuffer? sourceBuffer</dt>
        <dd>
          <p>Returns the <a>SourceBuffer</a> that created this track. Returns null if this track was not created by a <a>SourceBuffer</a> or the <a>SourceBuffer</a> has been removed from the <a def-id="sourceBuffers"></a> attribute of its <a def-id="parent-media-source"></a>.</p>
        </dd>
    </section>

    <section id="text-track-extensions">
      <h2>TextTrack Extensions</h2>
      <p>This section specifies extensions to the HTML <a def-id="text-track"></a> definition.</p>

      <dl title="partial interface TextTrack" class="idl">
        <dt>attribute DOMString kind</dt>
        <dd>
          <p>Allows the web application to get and update the track <a def-id="texttrack-kind"></a>.</p>
          <p>On getting, return the current value of the attribute. This is either the value provided when this object was created or the value provided on
            the last successful set operation.<p>
          <p>On setting, run the following steps:</p>
          <ol>
            <li>If the value being assigned to this attribute does not match one of the <a def-id="videoref" name="text-track-kind">text track kinds</a>, then abort these steps.</li>
            <li>Update this attribute to the new value.</li>
            <li>If the <a def-id="texttrack-sourceBuffer"></a> attribute on this track is not null, then
              <a def-id="queue-a-task-to-fire-an-event-named"></a> <a def-id="tracklist-change"></a> at
              <a def-id="texttrack-sourceBuffer"></a>.<a def-id="sourcebuffer-textTracks"></a>.
            </li>
            <li><a def-id="Queue-a-task-to-fire-an-event-named"></a> <a def-id="tracklist-change"></a> at the <a def-id="texttracks"></a> attribute on the
              HTMLMediaElement.
            </li>
          </ol>
        </dd>

        <dt>attribute DOMString language</dt>
        <dd>
          <p>Allows the web application to get and update the track <a def-id="texttrack-language"></a>.</p>
          <p>On getting, return the current value of the attribute. This is either the value provided when this object was created or the value provided on
            the last successful set operation.<p>
          <p>On setting, run the following steps:</p>
          <ol>
            <li>If the value being assigned to this attribute is not an valid <a def-id="videoref" name="text-track-language">text track language</a>, 
              then abort these steps.</li>
            <li>Update this attribute to the new value.</li>
            <li>If the <a def-id="texttrack-sourceBuffer"></a> attribute on this track is not null, then
              <a def-id="queue-a-task-to-fire-an-event-named"></a> <a def-id="tracklist-change"></a> at
              <a def-id="texttrack-sourceBuffer"></a>.<a def-id="sourcebuffer-textTracks"></a>.
            </li>
            <li><a def-id="Queue-a-task-to-fire-an-event-named"></a> <a def-id="tracklist-change"></a> at the <a def-id="texttracks"></a> attribute on the
              HTMLMediaElement.
            </li>
          </ol>
        </dd>

        <dt>readonly attribute SourceBuffer? sourceBuffer</dt>
        <dd>
          <p>Returns the <a>SourceBuffer</a> that created this track. Returns null if this track was not created by a <a>SourceBuffer</a> or the <a>SourceBuffer</a> has been removed from the <a def-id="sourceBuffers"></a> attribute of its <a def-id="parent-media-source"></a>.</p>
        </dd>
    </section>

    <section id="byte-stream-formats">
      <h2>Byte Stream Formats</h2>
      <p>The bytes provided through <a def-id="appendArrayBuffer"></a> and <a def-id="appendStream"></a> for a <a>SourceBuffer</a> form a logical byte stream. The format of this byte stream depends on the media container format in use and is defined in a byte stream format specification. Byte stream format specifications based on WebM , the ISO Base Media File Format, and MPEG-2 Transport Streams are provided below. These format specifications are intended to be the authoritative source for how data from these containers is formatted and passed to a <a>SourceBuffer</a>. If a <a>MediaSource</a> implementation claims to support any of these container formats, then it must implement the corresponding byte stream format specification described below.</p>
      <p>This section provides general requirements for all byte stream formats:</p>
      <ul>
        <li>A byte stream format specification must define <a def-id="init-segments"></a> and <a def-id="media-segments"></a>.</li>
        <li>It must be possible to identify segment boundaries and segment type (initialization or media) by examining the byte stream alone.</li>
        <li>The following rules apply to all <a def-id="init-segments"></a> within a byte stream:
          <ol>
            <li>
              <p>The number and type of tracks must be consistent.</p>
              <p>For example, if the first <a def-id="init-segment"></a> has 2 audio tracks and 1 video track, then all <a def-id="init-segments"></a> that follow it in the byte stream must describe 2 audio tracks and 1 video track.</p>
            </li>
	    <li>
              <p><a def-id="track-ids"></a> do not need to be the same across <a def-id="init-segments"></a> if the segment describes only one track of each type.</p>
              <p>For example, if an <a def-id="init-segment"></a> describes a single audio track and a single video track, the internal <a def-id="track-ids"></a> do not need to be the same.</p>
            </li>
            <li><a def-id="track-ids"></a> must be the same across <a def-id="init-segments"></a> if the segment describes multiple tracks of a single type. (e.g. 2 audio tracks).</li>
	    <li>
              <p>Codecs changes are not allowed.</p>
              <p>For example, a byte stream that starts with an <a def-id="init-segment"></a> that specifies a single AAC track and later contains an <a def-id="init-segment"></a> that specifies a single AMR-WB track is not allowed. Support for multiple codecs is handled with multiple <a>SourceBuffer</a> objects.</p>
            </li>
	    <li>
              <p>Video frame size changes are allowed and must be supported seamlessly.</p>
              <p class="note">This will cause the &lt;video&gt; display region to change size if the web application does not use CSS or HTML attributes (width/height) to constrain the element size.</p>
            </li>
	    <li>
              <p>Audio channel count changes are allowed, but they may not be seamless and could trigger downmixing.</p>
              <p class="note">This is a quality of implementation issue because changing the channel count may require reinitializing the audio device, resamplers, and channel mixers which tends to be audible.</p>
            </li>
          </ol>
        </li>
        <li>The following rules apply to all <a def-id="media-segments"></a> within a byte stream:
          <ol>
            <li>All timestamps must be mapped to the same presentation timeline.</li>
	    <li>Segments must start with a <a def-id="random-access-point"></a> to facilitate seamless splicing at the segment boundary.</li>
	    <li>Gaps between <a def-id="media-segments"></a> that are smaller than the audio frame size are allowed and must not cause playback to stall. Such gaps must not be reflected by <a def-id="buffered"></a>.
	      <p class="note">This is intended to simplify switching between audio streams where the frame boundaries don't always line up across encodings (e.g. Vorbis).</p>
            </li>
          </ol>
        </li>
        <li>The combination of an <a def-id="init-segment"></a> and any contiguous sequence of <a def-id="media-segments"></a> associated with it must:
	  <ol>
	    <li>Identify the number and type (audio, video, text, etc.) of tracks in the Segments</li>
	    <li>Identify the decoding capabilities needed to decode each track (i.e. codec and codec parameters)</li>
	    <li>If a track is encrypted, provide any encryption parameters necessary to decrypt the content (except the encryption key itself)</li>
	    <li>For each track, provide all information necessary to decode and render the earliest <a def-id="random-access-point"></a> in the sequence of Media Segments and all subsequent samples in the sequence (in presentation time). This includes, in particular,
	      <ul>
	        <li>Information that determines the <a def-id="intrinsic-width-and-height"></a> of the video (specifically, this requires either the picture or pixel aspect ratio, together with the encoded resolution).</li>
	        <li>Information necessary to convert the video decoder output to a format suitable for display</li>
	      </ul>
	    </li>
	    <li>Identify the global presentation timestamp of every sample in the sequence of Media Segments</li>
	  </ol>
	  <p>For example, if I1 is associated with M1, M2, M3 then the above must hold for all the combinations I1+M1, I1+M2, I1+M1+M2, I1+M2+M3, etc.</p>
        </li>
      </ul>
      <p>Byte stream specifications must at a minimum define constraints which ensure that the above requirements hold. Additional constraints may be defined, for example to simplify implementation.</p>

      <section id="webm" class="nonnormative">
        <h3>WebM Byte Streams</h3>
        <p>This section defines segment formats for implementations that choose to support WebM.</p>

        <section id="webm-init-segments">
          <h4>Initialization Segments</h4>
          <p>A WebM <a def-id="init-segment"></a> must contain a subset of the elements at the start of a typical WebM file.</p>
          <p>The following rules apply to WebM initialization segments:</p>
          <ol>
	    <li>The <a def-id="init-segment"></a> must start with an <a def-id="webm-ebml-header"></a> element, followed by a <a def-id="webm-segment"></a> header.</li>
	    <li>The size value in the <a def-id="webm-segment"></a> header must signal an "unknown size" or contain a value large enough to include the <a def-id="webm-info"></a> and <a def-id="webm-tracks"></a> elements that follow.</li>
	    <li>A <a def-id="webm-info"></a> element and a <a def-id="webm-tracks"></a> element must appear, in that order, after the <a def-id="webm-segment"></a> header and before any further <a def-id="webm-ebml-header"></a> or <a def-id="webm-cluster"></a> elements.</li>
	    <li>Any elements other than an <a def-id="webm-ebml-header"></a> or a <a def-id="webm-cluster"></a> that occur before, in between, or after the <a def-id="webm-info"></a> and <a def-id="webm-tracks"></a> elements are ignored.</li>
          </ol>
        </section>

        <section id="webm-media-segments">
          <h4>Media Segments</h4>
          <p>A WebM <a def-id="media-segment"></a> is a single <a def-id="webm-cluster"></a> element.</p>
          <p>The following rules apply to WebM media segments:</p>
          <ol>
	    <li>The Timecode element in the <a def-id="webm-cluster"></a> contains a presentation timestamp in TimecodeScale units.</li>
	    <li>The TimecodeScale in the <a def-id="webm-init-segment"></a> most recently appended applies to all timestamps in the <a def-id="webm-cluster"></a>
            </li>
	    <li>The Cluster header may contain an "unknown" size value. If it does then the end of the cluster is reached when another <a def-id="webm-cluster"></a> header or an element header that indicates the start of an <a def-id="webm-init-segment"></a> is encountered.</li>
	    <li>Block &amp; SimpleBlock elements must be in time increasing order consistent with the <a def-id="webm-spec"></a>.</li>
	    <li>If the most recent <a def-id="webm-init-segment"></a> describes multiple tracks, then blocks from all the tracks must be interleaved in time increasing order. At least one block from all audio and video tracks must be present.</li>
	    <li>
              <a def-id="webm-cues"></a> or <a def-id="webm-chapters"></a> elements may follow a <a def-id="webm-cluster"></a> element. These elements must be accepted and ignored by the user agent.</li>
          </ol>
        </section>

        <section id="webm-random-access-points">
          <h4>Random Access Points</h4>
          <p>A SimpleBlock element with its Keyframe flag set signals the location of a <a def-id="random-access-point"></a> for that track. Media segments containing multiple tracks are only considered a random access point if the first SimpleBlock for each track has its Keyframe flag set. The order of the multiplexed blocks must conform to the <a def-id="webm-muxer-guidelines"></a>.</p>
        </section>
      </section>
      
      <section id="iso" class="nonnormative">
        <h3>ISO Base Media File Format Byte Streams</h3>
        <p>This section defines segment formats for implementations that choose to support the ISO Base Media File Format
	  <a def-id="iso-14496-12"></a> (ISO BMFF).</p> 

	<section id="iso-init-segments">
          <h4>Initialization Segments</h4>
          <p>An ISO BMFF <a def-id="init-segment"></a> is defined in this specification as a single Movie Header Box (<span class="iso-box">moov</span>).
            The tracks in the  Movie Header Box must not contain any samples (i.e. the <span class="iso-var">entry_count</span> in the
            <span class="iso-box">stts</span>, <span class="iso-box">stsc</span> and <span class="iso-box">stco</span> boxes must be set to zero). A Movie
            Extends (<span class="iso-box">mvex</span>) box must be contained in the Movie Header Box to indicate that Movie Fragments are to be expected.
          </p>
          <p>The <a def-id="init-segment"></a> may contain Edit Boxes (<span class="iso-box">edts</span>) which provide a mapping of composition times for each track to the global presentation time.</p>
          <p>Valid top-level boxes such as <span class="iso-box">ftyp</span>, <span class="iso-box">styp</span>, and <span class="iso-box">sidx</span> are
            allowed to appear before the <span class="iso-box">moov</span> box. These boxes must be accepted and ignored by the user agent and are not
            considered part of the <a def-id="init-segment"></a> in this specification.</p>
	</section>
        
	<section id="iso-media-segments">
          <h4>Media Segments</h4>
          <p>An ISO BMFF <a def-id="media-segment"></a> is defined in this specification as a single Movie Fragment Box
            (<span class="iso-box">moof</span>) followed by one or more Media Data Boxes (<span class="iso-box">mdat</span>).</p>
          <p>Valid top-level boxes defined in <a def-id="iso-14496-12"></a> other than <span class="iso-box">moov</span>, 
            <span class="iso-box">moof</span>, and <span class="iso-box">mdat</span> are allowed to appear between the end of an
            <a def-id="init-segment"></a> or <a def-id="media-segment"></a> and before the beginning of a new <a def-id="media-segment"></a>.
            These boxes must be accepted and ignored by the user agent and are not considered part of the <a def-id="media-segment"></a> in this
            specification.
          </p>
          <p>The following rules apply to ISO BMFF media segments:</p>
          <ol>
	    <li>The Movie Fragment Box must contain at least one Track Fragment Box (<span class="iso-box">traf</span>).</li>
	    <li>The Movie Fragment Box must use movie-fragment relative addressing and the flag <span class="iso-var">default-base-is-moof</span> must be set; absolute byte-offsets must not be used.</li>
	    <li>External data references must not be used.</li>
	    <li>If the Movie Fragment contains multiple tracks, the duration by which each track extends should be as close to equal as practical.</li>
	    <li>Each Track Fragment Box must contain a Track Fragment Decode Time Box (<span class="iso-box">tfdt</span>)</li>
	    <li>The first sample in each Track Fragment Run Box (<span class="iso-box">trun</span>) must indicate that the sample is a <a def-id="random-access-point"></a>.</li>
	    <li>The Media Data Boxes must contain all the samples referenced by the Track Fragment Run Boxes (<span class="iso-box">trun</span>) of the Movie Fragment Box.</li>
          </ol>
	</section>

	<section id="iso-random-access-points">
          <h4>Random Access Points</h4>
          <p>A <a def-id="random-access-point"></a> as defined in this specification corresponds to a Stream Access Point of type 1 or 2 as defined in Annex I of <a def-id="iso-14496-12"></a>.</p>
	</section>
      </section>

      <section id="mpeg2ts" class="nonnormative">
        <h3>MPEG-2 Transport Stream Byte Streams</h3>
        <p>This section defines segment formats for implementations that choose to support MPEG-2 Transport Streams
          (MPEG-2 TS) specified in <a def-id="iso-13818-1"></a>.</p>
        
        <section id="mpeg2ts-general">
          <h4>General</h4>
          <p>MPEG-2 TS media and initialization segments must conform to the MPEG-2 TS Adaptive Profile (ISO/IEC 13818-1:2012 Amd. 2).</p>
          <p>The following rules must apply to all MPEG-2 TS segments:</p>
          <ol>
            <li>Segments must contain complete MPEG-2 TS packets.</li>
            <li>Segments must contain only complete PES packets and sections.</li>
            <li>Segments must contain exactly one program.</li>
            <li>All MPEG-2 TS packets must have the transport_error_indicator set to 0</li>
          </ol>
        </section>
        <section id="mpeg2ts-init-segments">
          <h4>Initialization Segments</h4>
          <p>An MPEG-2 TS initialization segment must contain a single PAT and a single PMT. Other SI, such as CAT, that are invariant for all subsequent
            media segments, may be present.</p>
        </section>
  
        <section id="mpeg2ts-media-segments">
          <h4>Media Segments</h4>
          <p>The following rules apply to all MPEG-2 TS media segments:</p>
          <ol>
            <li>PSI that is identical to the information in the initialization segment may appear repeatedly throughout the segment.</li>
            <li>The media segment will not rely on initialization information in another media segment.</li>
            <li>Media Segments must contain only complete PES packets and sections.</li>
            <li>Each PES packet must be comprised of one or more complete access units.</li>
            <li>Each PES packet must have a PTS timestamp.</li>
            <li>PCR must be present in the Segment prior to the first byte of a TS packet payload containing media data.</li>
            <li>The presentation duration of each media component within the Media Segment should be as close to equal as practical.</li>
          </ol>
        </section>

        <section id="mpeg2ts-random-access-points">
          <h4>Random Access Points</h4>
          <p>A random access point as defined in this specification corresponds to Elementary Stream Random Access Point as defined in 
            <a def-id="iso-13818-1"></a>.</p>
        </section>
        <section id="mpeg2ts-discontinuities">
          <h4>Timestamp Rollover &amp; Discontinuities</h4>
          <p>Timestamp rollovers and discontinuities must be handled by the UA. The UA's MPEG-2 TS implementation must maintain an internal offset
          variable, <dfn id="mpeg2ts-timestampOffset">MPEG2TS_timestampOffset</dfn>, to keep track of the offset that needs to be applied to timestamps
          that have rolled over or are part of a discontinuity. <var>MPEG2TS_timestampOffset</var> is initially set to 0 when the <a>SourceBuffer</a> is 
          created.  This offset must be applied to the timestamps as part of the conversion process from MPEG-2 TS packets
          into <a def-id="coded-frames"></a> for the <a def-id="coded-frame-processing-algorithm"></a>. This results in the coded frame timestamps 
          for a packet being computed by the following equations:</p>
          <pre>
Coded Frame Presentation Timestamp = (MPEG-2 TS presentation timestamp) + <var>MPEG2TS_timestampOffset</var>
Coded Frame Decode Timestamp = (MPEG-2 TS decode timestamp) + <var>MPEG2TS_timestampOffset</var></pre>

          <p><a def-id="mpeg2ts-timestampOffset"></a> is updated in the following ways:</p>
          <ul>
            <li>Each time a timestamp rollover is detected, 2^33 must be added to <var>MPEG2TS_timestampOffset</var>.</li>
            <li>When a discontinuity is detected, <var>MPEG2TS_timestampOffset</var> must be adjusted to make the timestamps after the discontinuity appear
              to come immediately after the timestamps before the discontinuity.</li>
            <li>When <a def-id="abort"></a> is called, <var>MPEG2TS_timestampOffset</var> must be set to 0.</li>
            <li>When <a def-id="timestampOffset"></a> is successfully set, <var>MPEG2TS_timestampOffset</var> must be set to 0.</li>
          </ul>
        </section>
      </section>
    </section>



    <section id="examples">
      <h2>Examples</h2>
      <p>Example use of the Media Source Extensions</p>
      <div class="block">
        <div class="blockContent">
          <pre class="code">
&lt;script&gt;
  function onSourceOpen(videoTag, e) {
    var mediaSource = e.target;
    var sourceBuffer = mediaSource.addSourceBuffer('video/webm; codecs="vorbis,vp8"');

    videoTag.addEventListener('seeking', onSeeking.bind(videoTag, mediaSource));
    videoTag.addEventListener('progress', onProgress.bind(videoTag, mediaSource));

    var initSegment = GetInitializationSegment();

    if (initSegment == null) {
      // Error fetching the initialization segment. Signal end of stream with an error.
      mediaSource.endOfStream("network");
      return;
    }

    // Append the initialization segment.
    var firstAppendHandler = function(e) {
      var sourceBuffer = e.target;
      sourceBuffer.removeEventListener('updateend', firstAppendHandler);

      // Append some initial media data.
      appendNextMediaSegment(mediaSource);
    };
    sourceBuffer.addEventListener('updateend', firstAppendHandler);
    sourceBuffer.appendArrayBuffer(initSegment);
  }

  function appendNextMediaSegment(mediaSource) {
    if (mediaSource.readyState == "ended")
      return;

    // If we have run out of stream data, then signal end of stream.
    if (!HaveMoreMediaSegments()) {
      mediaSource.endOfStream();
      return;
    }

    // Make sure the previous append is not still pending.
    if (mediaSource.sourceBuffers[0].appending)
        return;

    var mediaSegment = GetNextMediaSegment();

    if (!mediaSegment) {
      // Error fetching the next media segment.
      mediaSource.endOfStream("network");
      return;
    }

    mediaSource.sourceBuffers[0].appendArrayBuffer(mediaSegment);
  }

  function onSeeking(mediaSource, e) {
    var video = e.target;

    // Abort current segment append.
    mediaSource.sourceBuffers[0].abort();

    // Notify the media segment loading code to start fetching data at the
    // new playback position.
    SeekToMediaSegmentAt(video.currentTime);

    // Append a media segment from the new playback position.
    appendNextMediaSegment(mediaSource);
  }

  function onProgress(mediaSource, e) {
    appendNextMediaSegment(mediaSource);
  }
&lt;/script&gt;

&lt;video id="v" autoplay&gt; &lt;/video&gt;

&lt;script&gt;
  var video = document.getElementById('v');
  var mediaSource = new MediaSource();
  mediaSource.addEventListener('sourceopen', onSourceOpen.bind(this, video));
  video.src = window.URL.createObjectURL(mediaSource);
&lt;/script&gt;
          </pre>
        </div>
      </div>
    </section>

    <section id="revision-history">
      <h2>Revision History</h2>
      <table class="old-table">
        <thead>
          <tr>
            <th>Version</th>
            <th>Comment</th>
          </tr>
        </thead>
        <tbody>
          <tr>
	    <td>05 February 2013</a></td>
            <td>
              <ul>
                <li>Bug 19676 - Added a note clarifying that the internal timestamp representation doesn't have to be a double.</li>
                <li>Added steps to the coded frame processing algorithm to remove old frames when new ones overlap them.</li>
                <li>Fix isTypeSupported() return type.</li>
                <li>Bug 18933 - Clarify what top-level boxes to ignore for ISO-BMFF.</li>
                <li>Bug 18400 - Add a check to avoid creating huge hidden gaps when out-of-order appends occur w/o calling abort().</li>
              </ul>
            </td>
          </tr>
          <tr>
	    <td><a href="http://dvcs.w3.org/hg/html-media/raw-file/b35722b0cd8f/media-source/media-source.html">31 January 2013</a></td>
            <td>
              <ul>
                <li>Make remove() asynchronous.</li>
                <li>Added steps to various algorithms to throw an INVALID_STATE_ERR exception when async appends or remove() are pending.</li>
              </ul>
            </td>
          </tr>
          <tr>
	    <td><a href="http://dvcs.w3.org/hg/html-media/raw-file/aae26333e7d1/media-source/media-source.html">30 January 2013</a></td>
            <td>
              <ul>
                <li>Remove early abort step on 0-byte appends so the same events fire as a normal append with bytes.</li>
                <li>Added definition for 'enough data to ensure uninterrupted playback'.</li>
                <li>Updated buffered ranges algorithm to properly compute the ranges for Philip's example.</li>
              </ul>
            </td>
          </tr>
          <tr>
	    <td><a href="http://dvcs.w3.org/hg/html-media/raw-file/fd2a58eec443/media-source/media-source.html">15 January 2013</a></td>
            <td>Replace setTrackInfo() and getSourceBuffer() with AudioTrack, VideoTrack, and TextTrack extensions.</td>
          </tr>
          <tr>
	    <td><a href="http://dvcs.w3.org/hg/html-media/raw-file/52a85235137b/media-source/media-source.html">04 January 2013</a></td>
            <td>
              <ul>
                <li>Renamed append() to appendArrayBuffer() and made appending asynchronous.</li>
                <li>Added SourceBuffer.appendStream().</li>
                <li>Added SourceBuffer.setTrackInfo() methods.</li>
                <li>Added issue boxes to relevant sections for outstanding bugs.</li>
              </ul>
            </td>
          </tr>
          <tr>
	    <td><a href="http://dvcs.w3.org/hg/html-media/raw-file/53ea7c19edd2/media-source/media-source.html">14 December 2012</a></td>
            <td>
              Pubrules, Link Checker, and Markup Validation fixes.
            </td>
          </tr>
          <tr>
	    <td><a href="http://dvcs.w3.org/hg/html-media/raw-file/e1c91093dfdc/media-source/media-source.html">13 December 2012</a></td>
            <td>
              <ul>
                <li>Added MPEG-2 Transport Stream section.</li>
                <li>Added text to require abort() for out-of-order appends.</li>
                <li>Renamed "track buffer" to "decoder buffer".</li>
                <li>Redefined "track buffer" to mean the per-track buffers that hold the SourceBuffer media data.</li>
                <li>Editorial fixes.</li>
              </ul>
            </td>
          </tr>
          <tr>
	    <td><a href="http://dvcs.w3.org/hg/html-media/raw-file/ee6e8ae9337c/media-source/media-source.html">08 December 2012</a></td>
            <td>
              <ul>
                <li>Added MediaSource.getSourceBuffer() methods.</li>
                <li>Section 2 cleanup.</li>
              </ul>
            </td>
          </tr>
          <tr>
	    <td><a href="http://dvcs.w3.org/hg/html-media/raw-file/43be42e69533/media-source/media-source.html">06 December 2012</a></td>
            <td>
              <ul>
                <li>append() now throws a QUOTA_EXCEEDED_ERR when the SourceBuffer is full.</li>
                <li>Added unique ID generation text to Initialization Segment Received algorithm.</li>
                <li>Remove 2.x subsections that are already covered by algorithm text.</li>
                <li>Rework byte stream format text so it doesn't imply that the MediaSource implementation must support all formats supported by the
                  HTMLMediaElement.</li>
              </ul>
            </td>
          </tr>
          <tr>
	    <td><a href="http://dvcs.w3.org/hg/html-media/raw-file/0c638da9a67a/media-source/media-source.html">28 November 2012</a></td>
            <td>
              <ul>
                <li>Added transition to HAVE_METADATA when current playback position is removed.</li>
                <li>Added remove() calls to duration change algorithm.</li>
                <li>Added MediaSource.isTypeSupported() method.</li>
                <li>Remove initialization segments are optional text.</li>
              </ul>
            </td>
          </tr>
	  <tr>
	    <td><a href="http://dvcs.w3.org/hg/html-media/raw-file/3e4d27b3a98f/media-source/media-source.html">09 November 2012</a></td>
            <td>Converted document to ReSpec.</td>
          </tr>
	  <tr>
	    <td><a href="http://dvcs.w3.org/hg/html-media/rev/e029f71aafca">18 October 2012</a></td>
            <td>Refactored SourceBuffer.append() &amp; added SourceBuffer.remove().</td>
          </tr>
	  <tr>
	    <td><a href="http://dvcs.w3.org/hg/html-media/rev/6d127e69c9f8">8 October 2012</a></td>
            <td>
	      <ul>
	        <li>Defined what HTMLMediaElement.seekable and HTMLMediaElement.buffered should return.</li>
	        <li>Updated seeking algorithm to run inside Step 10 of the HTMLMediaElement seeking algorithm.</li>
	        <li>Removed transition from "ended" to "open" in the seeking algorithm.</li>
	        <li>Clarified all the event targets.</li>
	      </ul>
	    </td>
          </tr>
	  <tr>
	    <td><a href="http://dvcs.w3.org/hg/html-media/raw-file/7bab66368f2c/media-source/media-source.html">1 October 2012</a></td>
            <td>Fixed various addsourcebuffer &amp; removesourcebuffer bugs and allow append() in ended state.</td>
          </tr>
          <tr>
	    <td><a href="http://dvcs.w3.org/hg/html-media/raw-file/349559debcc3/media-source/media-source.html">13 September 2012</a></td>
            <td>Updated endOfStream() behavior to change based on the value of HTMLMediaElement.readyState.</td>
          </tr>
          <tr>
	    <td><a href="http://dvcs.w3.org/hg/html-media/raw-file/ca093bbbbefb/media-source/media-source.html">24 August 2012</a></td>
            <td>
	      <ul>
	        <li>Added early abort on to duration change algorithm.</li>
	        <li>Added createObjectURL() IDL &amp; algorithm.</li>
                <li>Added Track ID &amp; Track description definitions.</li>
                <li>Rewrote start overlap for audio frames text.</li>
                <li>Removed rendering silence requirement from section 2.5.</li>
	      </ul>
	    </td>
          </tr>
	  <tr>
	    <td><a href="http://dvcs.w3.org/hg/html-media/raw-file/340786fcae83/media-source/media-source.html">22 August 2012</a></td>
            <td>
	      <ul>
	        <li>Clarified WebM byte stream requirements.</li>
	        <li>Clarified SourceBuffer.buffered return value.</li>
	        <li>Clarified addsourcebuffer &amp; removesourcebuffer event targets.</li>
	        <li>Clarified when media source attaches to the HTMLMediaElement.</li>
	        <li>Introduced duration change algorithm and update relevant algorithms to use it.</li>
	      </ul>
	    </td>
          </tr>
          <tr>
	    <td><a href="http://dvcs.w3.org/hg/html-media/raw-file/032f7b8681d1/media-source/media-source.html">17 August 2012</a></td>
            <td>Minor editorial fixes.</td>
          </tr>
          <tr>
	    <td><a href="http://dvcs.w3.org/hg/html-media/raw-file/29687c019735/media-source/media-source.html">09 August 2012</a></td>
            <td>Change presentation start time to always be 0 instead of using format specific rules about the first media segment appended.</td>
          </tr>
	  <tr>
	    <td><a href="http://dvcs.w3.org/hg/html-media/raw-file/087ea42f59c8/media-source/media-source.html">30 July 2012</a></td>
            <td>Added SourceBuffer.timestampOffset and MediaSource.duration.</td>
          </tr>
          <tr>
	    <td><a href="http://dvcs.w3.org/hg/html-media/raw-file/ab36e8e882c6/media-source/media-source.html">17 July 2012</a></td>
            <td>Replaced SourceBufferList.remove() with MediaSource.removeSourceBuffer().</td>
          </tr>
	  <tr>
	    <td><a href="http://dvcs.w3.org/hg/html-media/raw-file/b499a199e427/media-source/media-source.html">02 July 2012</a></td>
            <td>Converted to the object-oriented API</td>
          </tr>
	  <tr>
	    <td><a href="http://dvcs.w3.org/hg/html-media/raw-file/9bbfe09653e4/media-source/media-source.html">26 June 2012</a></td>
            <td>Converted to Editor's draft.</td>
          </tr>
	  <tr>
	    <td><a href="http://dvcs.w3.org/hg/html-media/raw-file/e433598d22a7/media-source/media-source.html">0.5</a></td>
            <td>Minor updates before proposing to W3C HTML-WG.</td>
          </tr>
          <tr>
            <td><a href="http://html5-mediasource-api.googlecode.com/svn/tags/0.4/draft-spec/mediasource-draft-spec.html">0.4</a></td>
            <td>Major revision. Adding source IDs, defining buffer model, and clarifying byte stream formats.</td>
          </tr>
	  <tr>
            <td><a href="http://html5-mediasource-api.googlecode.com/svn/tags/0.3/draft-spec/mediasource-draft-spec.html">0.3</a></td>
            <td>Minor text updates.</td>
          </tr>
          <tr>
            <td><a href="http://html5-mediasource-api.googlecode.com/svn/tags/0.2/draft-spec/mediasource-draft-spec.html">0.2</a></td>
            <td>Updates to reflect initial WebKit implementation.</td>
          </tr>
          <tr>
            <td><a href="http://html5-mediasource-api.googlecode.com/svn/tags/0.1/draft-spec/mediasource-draft-spec.html">0.1</a></td>
            <td>Initial Proposal</td>
          </tr>
        </tbody>
      </table>
    </section>
  </body>
</html>
